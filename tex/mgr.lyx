#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass mwbk
\begin_preamble
\usepackage{thumbpdf}

\usepackage{fix-cm}

\usepackage{type1ec}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usepackage{dingbat}

%\usepackage[pdftex,man,opt]{wmstitle}
\usepackage[pdftex,type=mgr,gender=male]{aghtitle}
%\usepackage[bookmarks, bookmarksopen=true, bookmarksnumbered=true, colorlinks=true, pdftitle={System sterowania robotem mobilnym}, pdfauthor={Michał Fita}]{hyperref}

\usepackage[protrusion=true,expansion=true, tracking=true, spacing=true, kerning=true, selected=true, babel=true]{microtype}

% -- Here is the headers and footers configuration --
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[RO,LE]{\nouppercase{\leftmark}}
\fancyhead[LO,RE]{\nouppercase{\rightmark}}
\fancyfoot{} % clear all footer fields
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,RE]{\tiny Michał Fita, Akademia Górniczo-Hutnicza, Kraków 2008-2009}
\fancyfoot[CO,CE]{}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0pt}
% -- Here for opening pages --
\fancypagestyle{opening}{%
\fancyhf{} % clear all header and footer fields
\fancyfoot[LE,RO]{\thepage} % except the center
\fancyfoot[LO,RE]{\tiny Michał Fita, Akademia Górniczo-Hutnicza, Kraków 2008-2009}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}
% -- Here for closing pages --
\fancypagestyle{closing}{%
\fancyhf{} % clear all header and footer fields
\fancyhead[RO,LE]{\nouppercase{\leftmark}}
\fancyhead[LO,RE]{\nouppercase{\rightmark}}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0pt}
}
\end_preamble
\options wide,pdftex
\use_default_options false
\language polish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter luximono
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 87

\graphics default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "System sterowania robotem mobilnym"
\pdf_author "Michał Fita"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\branch ASN.1
\selected 0
\color #fae58d
\end_branch
\branch Lua
\selected 1
\color #aaff7f
\end_branch
\leftmargin 3.5cm
\topmargin 2.5cm
\rightmargin 2.1cm
\bottommargin 2.5cm
\headsep 0.2cm
\footskip 0.6cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},linewidth=154mm,prebreak={\carriagereturn}"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
promotor{dr inż.
 Roman Krasowski}
\end_layout

\begin_layout Plain Layout


\backslash
albumNumber{209034}
\end_layout

\end_inset


\end_layout

\begin_layout Title
System sterowania robotem mobilnym
\end_layout

\begin_layout Author
Michał Fita
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter*
Wstęp
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Słowo 
\begin_inset Quotes eld
\end_inset

robot
\begin_inset Quotes erd
\end_inset

 pojawia się po raz pierwszy w sztuce, której autorem jest czeski pisarz
 Karel Čapek.
 Określenie to szybko trafia pomiędzy okładki dzieł literatury fantastycznej,
 zmieniając pierwotne znaczenie ze sztucznie hodowanego człowieka na sztucznie
 konstruowanego człowieka, by przez kolejne lata ewoluować do dzisiejszego
 znaczenia elektromechanicznej maszyny wykonującej różnorodne prace.
 Premiera czeskiej sztuki miała miejsce w 1921 roku, a dziś prawie wiek
 później słowo 
\begin_inset Quotes eld
\end_inset

robot
\begin_inset Quotes erd
\end_inset

 jest tak powszechne, że mało kto wie, jaka jest jego geneza.
 Tym bardziej niewielu wie, że termin 
\begin_inset Quotes eld
\end_inset

robotyki
\begin_inset Quotes erd
\end_inset

 jako dziedziny badań naukowych stworzył Isaac Asimov, który użył go w swoim
 opowiadaniu w 1942 roku.
\end_layout

\begin_layout Plain Layout
Słowo to z kart książek szybko trafia do świata nauki i zaczyna żyć własnym
 życiem w raz z postępem technologii elektronicznej i mechanicznej.
 Choć dziś nadal robotyka przez wielu traktowana jest jako zabawa, niż poważna
 dziedzina naukowa, to jednak znaczenie robotyki we współczesnym świecie
 gwałtownie rośnie.
 Stosowanie robotów w produkcji przemysłowej jest już standardem; nie przypomina
ją one wyglądem człowieka, lecz za to są dobrze przystosowane do pracy,
 którą mają realizować.
\end_layout

\begin_layout Plain Layout
Ustanowienie 13 września 2007 roku -- przy wsparciu ze strony firmy Google
 -- nagrody 
\noun on
Lunar X Prize
\noun default

\begin_inset Foot
status open

\begin_layout Plain Layout
Szczegóły na stronie fundacji X Prize: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.xprize.org
\end_layout

\end_inset

.
\end_layout

\end_inset

 stawia robotykę przed nowym wyzwaniem wspieranym przez pieniądze prywatnych
 inwestorów na nową niespotykaną dotąd skalę, porównywalną z tą, która towarzysz
yła do 2004 roku wyścigowi o pobicie bariery atmosfery i kosmosu przez prywatny
 pojazd kosmiczny.
 Tym razem walka toczy się o konstrukcję robota, który jako pierwszy wyląduje
 na księżycu i pokona co najmniej 500 metrów po jego powierzchni przekazując
 na Ziemię zdjęcia i film video.
 Ogromna nagroda finansowa napędza do pracy siły i umysły, które wcześniej
 w ogóle nie zakładały zajęcia się takim problemem.
 Czeka nas fascynująca rywalizacja, a na rezultat ludzkość będzie czekać
 z tak samo zapartym tchem, jak na start Space Ship One.
\end_layout

\begin_layout Plain Layout
+
\end_layout

\begin_layout Plain Layout
Niedocenianym obszarem współczesnej inżynierii jest robotyka.
 Łączy ona w sobie wiedzę z dziedziny elektroniki, automatyki, mechaniki
 oraz inżynierii oprogramowania.
 Wielu nawet dziś uważa robotykę za zabawę, a nie poważną dziedzinę badawczo-roz
wojową.
 Lecz sukcesy takich projektów jak Mars Pathfinder czy DARPA Grand Challenge
 pokazują rosnące znaczenie robotyki we współczesnym świecie.
 Bill Gates powiedział: 
\begin_inset Quotes eld
\end_inset

Wiek XX był erą komputerów, wiek XXI będzie erą robotów
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
Słowo 
\begin_inset Quotes eld
\end_inset

robot
\begin_inset Quotes erd
\end_inset

 zostało po raz pierwszy użyte w sztuce 
\begin_inset Quotes eld
\end_inset

R.U.R.
\begin_inset Quotes erd
\end_inset

 (cz.
 
\emph on
Rosumovi Uměli Roboti
\emph default
 - Roboty Uniwersalne Rossuma), której autorem jest Karel Čapek - jeden
 z najbardziej uznanych pisarzy czeskich.
 Pierwotnie słowo to odnosiło się do istot żywych, sztucznie produkowanej
 uproszczonej wersji ludzi, jednakże dziś określa urządzenia mechaniczne.
 Termin 
\begin_inset Quotes eld
\end_inset

robotyka
\begin_inset Quotes erd
\end_inset

 użył poraz pierwszy znany autor literatury fantastycznej Isaac Asimov w
 roku 1942 roku w opowiadaniu 
\begin_inset Quotes eld
\end_inset

Zabawa w berka
\begin_inset Quotes erd
\end_inset

 (ang.
 
\shape italic
\lang british

\begin_inset Quotes eld
\end_inset

Runaround
\begin_inset Quotes erd
\end_inset


\shape default
\lang polish
).
 W jego literaturze pojawiają się również słynne trzy prawa robotyki:
\end_layout

\begin_layout Enumerate
Robot nie może skrzywdzić człowieka, ani przez zaniechanie działania dopuścić,
 aby człowiek doznał krzywdy.
\end_layout

\begin_layout Enumerate
Robot musi być posłuszny rozkazom człowieka, chyba że stoją one w sprzeczności
 z Pierwszym Prawem.
\end_layout

\begin_layout Enumerate
Robot musi chronić sam siebie, jeśli tylko nie stoi to w sprzeczności z
 Pierwszym lub Drugim Prawem.
 
\end_layout

\begin_layout Plain Layout
Idea sztucznej istoty pojawia się w historii znacznie wcześniej, w mitologii
 jest wiele sztucznych istot.
 Choć najbardziej znaną sztuczną istotą jest Golem, choć ten najbardziej
 legendarny pojawia się w drugiej połowie XVI jako dzieło rabina Jehudę
 Löw ben Bezalela z Pragi.
 Najstarszy zachowany projekt humanoidalnej sztucznej istoty to rysunki
 Leonarda da Vinci przedstawiające mechanicznego rycerza, który miał siadać,
 poruszać rękami, głową oraz szczęką.
 Pierwsze znane mechanizmy przypominające roboty są datowane na rok 1738
 i są dziełem Jacques de Vaucanson.
 Zbudował on androida grającego na flecie, gracza na tamburynie (obie konstrukcj
e nie przetrwały rewolucji francuskiej) oraz mechaniczną kaczkę.
 On też jako pierwszy zastosował walec do sterowania procesem produkcyjnym
 zamiast karty perforowanej.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Przedmiotem pracy jest sterownik mikroprocesorowy oraz zestaw oprogramowania
 dla sterownika oraz współpracującego komputera PC.
 Platformą mechaniczną jest robot zabawka Robo--Actor, który ma służyć do
 demonstracji działania układu i oprogramowania stworzonych w ramach tej
 pracy.
 W kolejnych rozdziałach zostały opisane tematy teoretyczne oraz zadania
 realizowane w celu konstrukcji sterownika oraz stworzenia oprogramowania
 zarówno sterownika mikroprocesorowego oraz systemu kontrolnego dla komputera
 PC.
\end_layout

\begin_layout Standard
Praca została podzielona na dwie logiczne części, z której pierwsza omawia
 teoretyczne zagadnienia związane z tematem robotyki i technologii stosowanych
 w realizacji projektu, a część druga opisuje praktyczną realizację wszystkich
 elementów z opisem kroków prowadzących do wyboru stosowanych rozwiązań.
 Wśród opisywanych tematów znajdują się przede wszystkim systemy wbudowane,
 systemy operacyjne czasu rzeczywistego, radiowa transmisja danych, sterowanie
 silników elektrycznych oraz przetwarzanie obrazu.
\end_layout

\begin_layout Standard
Układ sterownika mikroprocesorowego został zrealizowany na platformie AVR32
 firmy Atmel.
 Jest to rodzina 32 bitowych mikrokontrolerów występująca w dwóch głównych
 odmianach, lekkiej odmianie UC3 dla mocno zintegrowanych rozwiązań, oraz
 AP7 -- odmianie wysokowydajnych mikrokontrolerów dla zaawansowanych aplikacji
 przenośnych, mogący między innymi pracować pod kontrolą systemu Linux.
 Istotną przewagą oferty firmy Atmel i układów AVR32 nad układami innych
 producentów jest bardzo silne wsparcie dla amatorów oraz środowiska otwartego
 oprogramowania.
\end_layout

\begin_layout Part
Wprowadzenie teoretyczne
\end_layout

\begin_layout Chapter
Historia
\end_layout

\begin_layout Section
Starożytność
\end_layout

\begin_layout Section
Średniowiecze
\end_layout

\begin_layout Section
Czasy Napoleońskie
\end_layout

\begin_layout Standard
W okresie panowania Napoleona i jego europejskich podbojów do historii zapisał
 się 
\shape slanted
Mechaniczny Turek
\shape default
, który miał być wybitnym automatem do gry w szachy.
 Skonstruowany w 1770 roku by zaimponować cesarzowej Marii Teresie przez
 barona Wolfganga von Kempelena mechanizm przez prawie 80 lat podbijał Europę
 i Amerykę.
 W historii i legendzie zapisał się, gdy rzekomo w 1809 roku pokonał samego
 Napoleona, uważanego za szachowego mistrza
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Niektóre źródła podają, że mistrzostwo Napoleona wynikało ze strachu jego
 przeciwników przed przegraną.
\end_layout

\end_inset

 oraz kilku innych wybitnych szachistów tamtych czasów, w tym Benjamina
 Franklina.
 
\end_layout

\begin_layout Standard
Choć prawdziwy sekret tej mechanicznej maszyny został ujawniony dopiero
 w 1859 roku, już po zniszczeniu maszyny w pożarze Muzeum Peale w 1854 roku,
 to tajemnica wydała się wcześniej.
 Tajemnica została zdradzona w 1834 roku przez szachistę o nazwisku Mälzl,
 który nie stronił od alkoholu, a był wielokrotnie we wnętrzu 
\shape slanted
Turka
\shape default
 jako gracz przez kilka wcześniejszych lat.
 W tym czasie 
\shape slanted
Turek
\shape default
 podróżował po Ameryce.
\end_layout

\begin_layout Standard
Do czasu powstanie komputera DeepBlue w 1997 roku nie podjęto poważnej próby
 przeciwstawienia maszyny największym mistrzom szachów.
 Mechanizm ten jednak był szczytem technologii mechanicznej tamtego okresu
 i można odważyć się na nazwanie go robotem sterowanym przez człowieka.
 Mimo, że był dobrze kamuflowanym oszustem, przez kilkadziesiąt lat szokował
 obserwatorów wierzących, że 
\shape slanted
Turek
\shape default
 jest mechanicznym samodzielnym graczem.
\end_layout

\begin_layout Standard
W historii 
\shape slanted
Mechanicznego Turka
\shape default
 jest też silny polski wątek, związany misją jaką brytyjski agent Beniamin
 Bathurst miał wykonywać w roku 1806 mającą na celu porwanie Napoleona.
 Przedmiotem pomagającym w dywersji miał być właśnie wspomniany 
\shape slanted
Turek
\shape default
 von Kempelena.
 Ten rzekomy fakt historyczny jest dokładnie opisany w memoriale, do którego
 dostęp uzyskał Waldemar Łysiak w trakcie studiów i zamienił potem na fabularyzo
waną historię 
\begin_inset CommandInset citation
LatexCommand cite
key "szachista-lysiak"

\end_inset

.
 Wiele osób wątpi, czy jest to historia prawdziwa, choć mowa w niej o polskim
 zakonniku Stefanie Błażejewskim, którego życiorys zapisany w archiwach
 klasztoru w Gostyniu odpowiada zakonnikowi opisywanemu jako sobowtór Napoleona.
\end_layout

\begin_layout Section
Współczesność
\end_layout

\begin_layout Chapter
Interfejsy
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Interfejs-JTAG"

\end_inset

Interfejs JTAG
\end_layout

\begin_layout Standard
Interfejs JTAG jest uznanym światowym standardem sprzętowego sprzęgu mikroproces
orów i układów programowalnych ze stanowiskiem pracy inżyniera, czyli komputera
 PC.
 Popularnie używany skrót JTAG od nazwy Joint Test Action Group to historyczna
 zaszłość z 1985 roku, gdy powołano grupę przemysłową do opracowania metod
 testowania płytek drukowanych na etapie postprodukcji.
 Założeniem grupy było opracowanie mechanizmu pozwalającego na testowanie
 połączeń z dowolnej nóżki złożonego układu scalonego po ścieżce poprowadzonej
 po płytce drukowanej.
 W roku 1990 metoda ta została zatwierdzona jako standard IEEE 1149.1
\begin_inset CommandInset citation
LatexCommand cite
key "jtag-std"

\end_inset

.
 Tego samego roku INTEL włożył obsługę tego standardu do procesora 80486.
\end_layout

\begin_layout Standard
Zastosowana metoda testowania pozwalała weryfikować elektryczne połączenia
 na płytce drukowanej z otoczeniem układu, stąd nosi nazwę ścieżki krawędziowej
 lub rzadziej skanowania granicznego (ang.
 
\shape italic
\lang british
boundary-scan
\shape default
\lang polish
).
 Polega ona na zastosowaniu pojedynczych bramek (ang.
 
\shape italic
\lang british
Boundary Scan Cells
\shape default
\lang polish
) na wszystkich nóżkach sygnałowych układu scalonego, które mogą być wymuszane
 w stan logiczny zero lub jeden, mogą odczytywać stan logiczny nóżki podawany
 z zewnątrz lub w trakcie normalnej pracy układu pozostawać nieaktywne i
 odizolowane od wyprowadzenia.
 Łańcuch takich bramek tworzy rejestr (ang.
 
\shape italic
\lang british
Boundary Scan Register
\shape default
\lang polish
), który współpracuje z dodatkowymi rejestrami instrukcji i danych.
\end_layout

\begin_layout Standard
W dzisiejszych czasach znaczenie interfejsu IEEE 1149.1 i wszelkich jego
 pochodnych specyficznych dla różnych producentów ma tak naprawdę największe
 znaczenie na etapie przygotowywania oprogramowania dla urządzeń wyposażonych
 w mikrokontrolery.
 O ile architektura sprzętowa szeregowej komunikacji z wewnętrznymi układami
 mikrokontrolerów została zachowana to każdy producent stosuje swoje rozszerzeni
a i wymaga własnego oprogramowania do sterowania interfejsem, które umożliwia
 programowanie pamięci Flash w układach oraz przeprowadzanie złożonego procesu
 uruchomieniowego wspomaganego przez sprzętowe pułapki.
 Programowanie układów scalonych z zastosowaniem tej metody (ale nie tylko)
 nazywa się programowaniem w systemie (ang.
 
\shape italic
\lang british
in-system programming
\shape default
\lang polish
, w skrócie ISP).
 Przykłady wielu mikrokontrolerów 8-bitowych pokazują, że ISP nie wymaga
 istnienia pełnego IEEE 1149.1 a wymaga tylko dostarczenia wyprowadzeń pozwalając
y szeregowo programować pamięć Flash lub sieć bramek wewnątrz układu scalonego
 (tak robi ATMEL z rodziną układów 8-bitowych i Xilinx dla układów CPLD).
\end_layout

\begin_layout Subsection
Zasada działania JTAG
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename vector/jtag-internals-01.svg
	lyxscale 50
	height 30pheight%
	BoundingBox 0bp 0bp 999bp 831bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-blokowy-implementacji"

\end_inset

Schemat blokowy implementacji JTAG w układzie 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prezentowany na 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-blokowy-implementacji"

\end_inset

 diagram wewnętrznej architektury JTAG wbudowanej w układzie pokazuje, jak
 pojedyncze wyprowadzenia układu mogą być testowane i ustawiane przez pojedyncze
 komórki rejestru.
 Rejestr ten przypomina klasyczny rejestr przesuwny i jest aktywowany w
 trybie testowym przez wejście TMS, przy czym w zależności od instrukcji
 przesłanej na wejście TDI wartość komórki jest odczytywana i wyprowadzana
 poprzez odpowiedź wysyłaną na wyjście TDO, bądź programowana wartością
 przesłaną razem z rozkazem JTAG.
 Rejestr ten jest taktowany częstotliwością podawaną przez urządzenie testujące
 na wejście TMS, kierunek działania rejestru jest jeden.
 Za poprawną obsługę danych pochodzących z poszczególnych komórek testujących
 odpowiada urządzenie sterujące.
\end_layout

\begin_layout Standard
Obsługa interfejsu odbywa się szeregowo z dużą szybkością, często zbliżoną
 do prędkości pracy układu w gotowym systemie, stąd wymagania dla urządzeń
 obsługujących interfejs zgodny z IEEE 1149.1 we współczesnych układach 32
 bitowych są naprawdę wyśrubowane, co wpływa również na cenę tych urządzeń.
 Jednym z takich urządzeń firmy Atmel jest JTAG ICE mk-II opisywany w rozdziale
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE"

\end_inset

.
\end_layout

\begin_layout Standard
Technikę ścieżki krawędziowej można wykorzystywać w celu przetestowania
 różnych elementów.
 W układzie wspierającym JTAG możliwe jest testowanie zarówno samych układów
 i połączeń poza układem.
 Możliwe jest testowanie elementów nie posiadających własnych wyprowadzeń
 dla JTAG, taki jak pamięci RAM.
 Testy polegają wtedy na takim sterowaniu wyprowadzeń układu, jak przy normalnej
 współpracy układem pamięci (lub innym testowanym) i odczytywanie stanów
 z wyprowadzeń układu.
 Przypomina to wtedy rzeczywiste zachowanie układu testowanego w systemie.
\end_layout

\begin_layout Standard
Wykorzystanie wszystkich możliwości JTAG do testowania, wymaga programu
 potrafiącego wiernie symulować zachowanie komórek ścieżki krawędziowej,
 w zastosowanych układach.
 Na rynku dostępne jest oprogramowanie, pozwalające na kompleksowe sterowanie
 testowanie i programowanie przez IEEE 1149.1.
 Wśród jego producentów są takie firmy jak JTAG Technologies, XJTAG, Corelis,
 Intellitech, Universal Scan, Applegate czy Temento Sytems.
 Oprogramowanie to wykorzystuje pliki BSDL, dostarczane przez producentów
 układów scalonych zawierających JTAG.
 Zawierają one dokładny sformalizowany opis umieszczonych w układzie komórek
 JTAG i ich otoczenia.
 Treść pliku zapisana jest w języku BSDL (ang.
 
\shape italic
\lang british
Boundary-Scan Description Language
\shape default
\lang polish
), który został opracowany na podstawie wybranych elementów składni języka
 VHDL.
 Na podstawie wgranych plików oraz wygenerowanych wektorów testowych, oprogramow
anie sterujące potrafi dość dokładnie obliczyć przewidywany procent pokrycia
 uszkodzeń.
 Umożliwia także precyzyjne zlokalizowanie uszkodzenia, w przypadku, gdy
 otrzymany na wyjściu ścieżki ciąg bitów, nie będzie zgadzał się z przewidywanym.
 (na podstawie 
\begin_inset CommandInset citation
LatexCommand cite
key "jtag-elektronik-online"

\end_inset

)
\end_layout

\begin_layout Subsection
Zalety stosowania JTAG
\end_layout

\begin_layout Standard
Ścieżka krawędziowa jest metodą prostą w implementacji i jest względnie
 tania w stosowaniu.
 Wyróżnia się pozytywnie na tle innych dostępnych metod testowania układów
 elektronicznych.
 Większość z testów dostępnych za pomocą ścieżki krawędziowej jest możliwa
 do wykonania także za pomocą łoża szpilkowego
\begin_inset Foot
status open

\begin_layout Plain Layout
łoże szpilkowe (ang.
 
\shape italic
\lang british
nail bed tester
\shape default
\lang polish
), to podłoże z drobnymi, gęsto rozmieszczonymi szpilkami, stykającymi się
 w punktach kontaktowych z punktami testowymi na płytce drukowanej, pomiędzy
 którymi dokonuje się pomiaru parametrów sygnału elektrycznego; koszty testera
 tego typu to rząd kilkunastu do setek tysięcy dolarów.
 
\end_layout

\end_inset

 to ta technika jest nieporównywalnie droższa.
 Zwiększenie powierzchni płytki drukowanej przez ulokowanie dodatkowych
 punktów testowych na powierzchni PCB również podnosi koszty takiego testu.
 Z racji swych ograniczeń, JTAG nie może zastąpić pełnej funkcjonalności
 testera igłowego, związanej przykładowo z testowaniem układu pod kątem
 bardzo szybkich impulsów i innych niestandardowych sygnałów.
 Zdarza się i tak, że ścieżka brzegowa oferuje możliwości, których zwykłe
 łoże szpilkowe nie jest w stanie zapewnić.
 Przykładem jest testowanie układów BGA, wybieranych przez producenta w
 celu ograniczenia rozmiarów urządzenia.
 Dostosowanie płytki z układem BGA do testowania za pomocą igieł wymaga
 wyprowadzenia bardzo wielu dodatkowych punktów testowych, co spowoduje
 znaczny wzrost jej powierzchni.
 Co prawda, JTAG nie jest jedyną sprawną metodą testowania układów BGA w
 systemie, ale konkurencyjna opcja, polegająca na prześwietlaniu zmontowanej
 płytki, za pomocą promieni X, nie tylko wymaga większych nakładów, ale
 może być niebezpieczna zarówno dla testowanej elektroniki, jak i pracowników
 laboratorium.
\end_layout

\begin_layout Standard
Kolejna zaleta posiadania JTAG w układzie to możliwość jego testowania przez
 cały czas jego życia.
 Zastosowanie JTAG pozwala w dowolnej chwili wykonać testy w trybie testowania
 i w prosty sposób ocenić jego sprawność, bez konieczności wymontowywania
 podzespołów lub umieszczania systemu w specjalnych maszynach testujących.
 Wbudowanie logiki testera na płytkę drukowaną z układem pozwala przeprowadzać
 testy bez konieczności dołączania zewnętrznych urządzeń testujących.
 Daje to możliwość regularnego kontrolowania sprawności układu, dzięki czemu
 jest możliwe zapewnienie wysokiego poziomu bezpieczeństwa i jakości pracy
 całego urządzenia.
 (na podstawie 
\begin_inset CommandInset citation
LatexCommand cite
key "jtag-elektronik-online,why-jtag-works"

\end_inset

)
\end_layout

\begin_layout Subsection
Wady stosowania JTAG
\end_layout

\begin_layout Standard
Dla wielu producentów cyfrowego sprzętu elektronicznego istnienie wyprowadzeń
 dla JTAG stanowi zagrożenie dla naruszenia dóbr intelektualnych zawartych
 w rozwiązaniach zastosowanych w sprzedawanych urządzeniach.
 Umiejętnie zastosowany JTAG pozwala na przeprowadzanie inżynierii odwrotnej
 układu i oprogramowania w nim zawartego (mimo zabezpieczenia wewnętrznej
 pamięci Flash przed bezpośrednim odczytem).
 Dzięki takim możliwościom, kilka bardzo popularnych urządzeń
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Popularny router Linksys WRT54G posiada alternatywne oprogramowanie, dostępne
 głównie na http://www.openwrt.org.
\end_layout

\end_inset

 zyskało szerokie grono użytkowników ze środowiska oprogramowania otwartego,
 które tworzy własne wersje oprogramowania o alternatywnych możliwościach.
 Nieliczni producenci zdecydowali się z sukcesem wspierać w pewnym stopniu
 takie działania środowisk użytkowników.
 Im więcej można zrobić z urządzeniem przez modyfikację oprogramowania,
 tym wyższe ceny tych urządzeń są na rynku wtórnym.
\end_layout

\begin_layout Subsection
On-chip debugging
\end_layout

\begin_layout Standard
Rozszerzenia producentów wbudowane w układ pozwalają na stosowanie JTAG
 do uruchamiania i odpluskwiania programów działających w rzeczywistym systemie
 (ang.
 
\shape italic
\lang british
on-chip debugging
\shape default
\lang polish
).
 Wykorzystuje się w tym celu możliwości 
\begin_inset Quotes pld
\end_inset

okłamywania
\begin_inset Quotes prd
\end_inset

 wejść logicznych procesora, czasem wirtualnie zawartych w konstrukcji układu.
 Dzięki temu proces działania aplikacji jest monitorowany przez urządzenie
 zewnętrzne, kontrolowane ze stanowiska inżyniera pracującego nad programem.
 W połączeniu z wbudowanymi w układ mechanizmami sprzętowymi, komunikacja
 między debuggerem na komputerze a wnętrzem procesora odbywa się w sposób
 przeźroczysty dla programu -- jednakże należy mieć na uwadze, że liczba
 cykli procesora zużywana na takie działanie może nie pozostawać bez wpływu
 na zachowanie szczególnie wrażliwego kodu (obsługa przerwań, timerów, itp.)
\end_layout

\begin_layout Standard
Istnieją alternatywne metody sprzętowego wspierania uruchomień programów,
 dla których powstały doskonalsze technicznie rozwiązania.
 Zastosowany w opisywanym sterowniku mikrokontroler, posiada interfejs Nexus
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
zdefiniować dokładnie
\end_layout

\end_inset

, który pozwala na bardzo dokładnie śledzenie zachowania programu, jego
 interakcji z pamięcią i rejestrami, przy zachowaniu całkowitej transparentności
 dla działającego mikrokontrolera.
 W tej technice wykorzystany jest fakt, że komputer na stanowisku pracy
 inżyniera jest wielokrotnie szybszy od uruchamianego urządzenia i jest
 możliwe wczytywanie śladu wykonania w czasie rzeczywistym przykładowo na
 dysk twardy komputera.
 Ponieważ ta technologia nie została tu użyta, nie będzie opisywana dokładniej.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Interfejs-USB"

\end_inset

Interfejs USB
\end_layout

\begin_layout Standard
Interfejs USB (ang.
 
\shape italic
\lang british
Universal Serial Bus
\shape default
\lang polish
) jest dziś najpopularniejszym interfejsem szeregowym dla różnych urządzeń
 współpracujących ze sobą, również komputerów z urządzeniami wejścia-wyjścia
 i urządzeniami multimedialnymi, takimi jak odtwarzacze muzyki, aparaty
 i kamery cyfrowe.
 Ogromna ilość narzędzi dla elektroników korzysta już z interfejsu USB (w
 tym JTAG ICE mk-II opisany w rozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE"

\end_inset

 oraz zestaw EVK1100 opisany w rozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:EVK1100"

\end_inset

).
 Jednakże implementacja USB we własnym urządzeniu może być z wielu względów
 kłopotliwa.
 Poniższy opis techniczny wyjaśni dlaczego tak jest i jakie stosuje się
 aktualnie rozwiązania tego problemu.
\end_layout

\begin_layout Standard
Standard USB został oficjalnie ogłoszony w 1996 roku przez konsorcjum złożone
 z firm: Compaq, DEC, IBM, Intel, Microsoft, Nec i Northern Telecom.
 Zatwierdzono wtedy standard USB 1.0, który istniał do 1999 roku, zyskał
 popularność gdy Microsoft i Apple wprowadziły sterowniki USB do swoich
 systemów operacyjnych.
 Od tamtego momentu USB występuje aktualnie w dwóch obowiązujących wersjach:
\end_layout

\begin_layout Description
USB
\begin_inset space ~
\end_inset

1.1 Standard ten koryguje braki standardu w wersji 1.0 i stosowany od 1999
 roku jest do dziś w większości urządzeń wejścia-wyjścia, gdyż jest prostszy
 w implementacji od USB 2.0.
 Obsługuje dwie standardowe prędkości transmisji danych 1,5
\begin_inset space ~
\end_inset

Mbit/s oraz 12
\begin_inset space ~
\end_inset

Mbit/s.
 Do jednego kontrolera może być podłączonych maksymalnie 127 urządzeń.
\end_layout

\begin_layout Description
USB
\begin_inset space ~
\end_inset

2.0 Istniejący od roku 2000 standard ten wprowadza tryb dużej prędkości (ang.
 
\shape italic
\lang british
High Speed USB
\shape default
\lang polish
) o prędkości 480
\begin_inset space ~
\end_inset

Mbit/s.
 Dodatkowo w roku 2001 pojawia się suplement On-the-Go pozwalające łączyć
 ze sobą takie urządzenia jak dysk twardy i aparat cyfrowy, polegające na
 negocjacji, które z połączonych urządzeń będzie pełnić rolę hosta.
\end_layout

\begin_layout Description
USB
\begin_inset space ~
\end_inset

3.0 Opublikowany 17 listopada 2008 roku standard wprowadza łącze optyczne
 obok elektrycznego, prędkość maksymalna 4,8
\begin_inset space ~
\end_inset

Gbit/s (ang.
 
\shape italic
\lang british
Super Speed USB
\shape default
\lang polish
) oraz pracę w pełnym dupleksie.
 Nowością ma być też zaawansowany sposób zarządzania zasilaniem urządzeń
 pracujących na magistrali -- nieużywane urządzenie może zostać samodzielnie
 wyłączone przez kontroler hosta.
 Powstanie tego standardu może przyczynić się do śmierci standardu IEEE.1394
 , zwanego inaczej FireWire.
\end_layout

\begin_layout Standard
Urządzenia podłączone do portów interfejsu USB nie wymagają dodatkowego
 zasilania w przypadku spełniania pewnych warunków, standardowo pojedynczy
 port może zostać obciążony prądem 100
\begin_inset space ~
\end_inset

mA.
 Po wykonaniu programowej konfiguracji port powinien umożliwiać pobór do
 500
\begin_inset space ~
\end_inset

mA.
 Fakt ten jest wykorzystywany jest już nawet do ładownia telefonów komórkowych
 podłączonych przez port USB do komputera PC.
 Aktualnie trwają pracę nad stworzeniem standardu Powered USB, który umożliwi
 zasilanie urządzeń nawet napięciem 24
\begin_inset space ~
\end_inset

V i obciążeniem do 6
\begin_inset space ~
\end_inset

A, co pozwoliłoby na rezygnację z zasilania zewnętrznego takich urządzeń
 jak drukarki, czy skanery.
\end_layout

\begin_layout Standard
Wśród nowości związanych z USB warto wspomnieć powstanie standardu Wireless
 USB, który zachowując zgodność komunikacyjną ze zwykłym USB miałby umożliwiać
 standaryzowaną bezprzewodową komunikację wielu urządzeń, w tym wejścia-wyjścia
 oraz na przykład fotograficznych aparatów cyfrowych.
\end_layout

\begin_layout Subsection
Zasada działania USB
\end_layout

\begin_layout Standard
Specyfikacja standardu USB określa precyzyjnie wszystkie aspekty związane
 z implementacją obsługi portu i komunikacji, co obejmuje również mechaniczną
 konstrukcję gniazd i wtyków USB, wymagania elektryczne okablowania.
 Dodatkowo istnieją specyfikacje dla kontrolerów hostów USB:
\end_layout

\begin_layout Description
UHCI (ang.
 
\shape italic
\lang british
Universal Host Controller Interface
\shape default
\lang polish
) opracowany przez Intela, który kładzie największy nacisk na oprogramowania
 redukując koszty sprzętu.
\end_layout

\begin_layout Description
OHCI (ang.
 
\shape italic
\lang british
Open Host Controller Interface
\shape default
\lang polish
) opracowany wspólnie przez Compaq, Microsoft i National Semiconductor,
 który kładzie największy nacisk na część sprzętową redukując oprogramowanie
 kontrolera do minimum.
\end_layout

\begin_layout Description
EHCI (ang.
 
\shape italic
\lang british
Enhanced Host Controller Interface
\shape default
\lang polish
) opracowany dopiero na potrzeby USB 2.0 przez Intel, Compaq, NEC, Lucent
 i Microsoft.
 Łączy pełne elementy tworząc wspólny standard współpracy urządzeń USB,
 również z rozszerzeniem On-the-Go.
\end_layout

\begin_layout Standard
Fizycznie interfejs USB jest magistralą szeregową zrealizowaną na 4 przewodach,
 z których dwa dostarczają zasilanie +5
\begin_inset space ~
\end_inset

V oraz GND.
 Pozostałe dwa przewody tworzą skręconą parę transmitującą sygnały różnicowe.
 Wykorzystywane jest przy tym kodowanie NRZI (ang.
 
\shape italic
\lang british
Non Return to Zero Invert
\shape default
\lang polish
) do transmisji danych zawierające pole synchronizacyjne dla uzgadniania
 synchronizacji zegarów urządzeń podpiętych do magistrali.
 Zastosowane kodowanie NRZI działa na zasadzie zmiany stanu na linii transmisyjn
ej w sytuacji transmitowania logicznej jedynki.
 Wadą tego rozwiązania jest utrata synchronizacji przy długich ciągach zer,
 stąd dodanie pól synchronizacyjnych w logicznej strukturze transmisji USB.
\end_layout

\begin_layout Standard
Dla niskiej (1,5
\begin_inset space ~
\end_inset

MBit/s) i pełnej (12
\begin_inset space ~
\end_inset

Mbit/s) prędkości transmisji kodowanie różnicowego zera (oznaczanego symbolem
 
\begin_inset Quotes eld
\end_inset

K
\begin_inset Quotes erd
\end_inset

) odbywa się przez podciąganie linii D+ ponad 2,8
\begin_inset space ~
\end_inset

V rezystorem 15
\begin_inset space ~
\end_inset

k
\begin_inset Formula $\Omega$
\end_inset

 podłączonym do masy, a linii D-- poniżej 0,3
\begin_inset space ~
\end_inset

 poprzez rezystor 1,5
\begin_inset space ~
\end_inset

k
\begin_inset Formula $\Omega$
\end_inset

 podłączony do 3,6
\begin_inset space ~
\end_inset

V.
 Kodowanie różnicowej jedynki (oznaczanej symbolem 
\begin_inset Quotes eld
\end_inset

J
\begin_inset Quotes erd
\end_inset

) odbywa się przez podciąganie D-- powyżej 2,8
\begin_inset space ~
\end_inset

V i D+ poniżej 0,3
\begin_inset space ~
\end_inset

V poprzez te same rezystory.
 Dla odbiornika sygnał 
\begin_inset Quotes eld
\end_inset

J
\begin_inset Quotes erd
\end_inset

 jest zdefiniowany jako D+ większe o 200
\begin_inset space ~
\end_inset

mV od D--, a sygnał 
\begin_inset Quotes eld
\end_inset

K
\begin_inset Quotes erd
\end_inset

 jako D+ mniejsze o 200
\begin_inset space ~
\end_inset

mV od D--.
 Polaryzacja sygnału zamienia się dla wysokiej prędkości (480
\begin_inset space ~
\end_inset

Mbit/s) i 
\begin_inset Quotes eld
\end_inset

J
\begin_inset Quotes erd
\end_inset

 oznacza różnicową 1, a 
\begin_inset Quotes eld
\end_inset

K
\begin_inset Quotes erd
\end_inset

 oznacza różnicowe 0.
\end_layout

\begin_layout Standard
Transceivery USB obsługują sygnalizację różnicową opisaną powyżej, ale również
 mogą indywidualnie terminować linie D-- i D+, co jest stosowane do specjalnej
 sygnalizacji na magistrali (jest to możliwe dzięki zasilaniu magistrali
 USB).
 Przykładowo sygnał SE0 jest otrzymywany przez utrzymanie niskiego stanu
 na obu liniach D-- i D+.
 Nie można tego faktu pomijać przy implementacji interfejsu USB, gdyż nie
 wystarczy porównywanie sygnałów różnicowych dla realizacji prawidłowej
 komunikacji po magistrali USB.
\end_layout

\begin_layout Standard
Impedancja linii dla niskiej i pełnej prędkości wynosi według specyfikacji
 90
\begin_inset space ~
\end_inset


\begin_inset Formula $\Omega\ \pm$
\end_inset


\begin_inset space ~
\end_inset

15%.
 Tryb wysokiej prędkości wymaga stałego prądu 17,78
\begin_inset space ~
\end_inset

mA dla sygnalizacji, co ma redukować poziom szumu.
\end_layout

\begin_layout Standard
Identyfikacja prędkości urządzenia odbywa się przez podciąganie linii D+
 do 3,3
\begin_inset space ~
\end_inset

V dla pełnej prędkości lub przez podciąganie D-- do 3,3
\begin_inset space ~
\end_inset

V dla niskiej prędkości przez rezystor 1,5
\begin_inset space ~
\end_inset

k
\begin_inset Formula $\Omega$
\end_inset

.
 Brak jednego z tych podciągnięć spowoduje niewykrycie urządzenia.
 Część układów scalonych posiada te rezystory wbudowane, można je wtedy
 kontrolować programowo, jednak część wymaga rezystora zewnętrznego według
 specyfikacji.
 Identyfikacja wysokiej prędkości urządzanie odbywa się na drodze negocjacji
 z hubem, a po jego włączeniu rezystor podciągający jest odłączany.
\end_layout

\begin_layout Subsection
Identyfikacja urządzeń USB
\end_layout

\begin_layout Standard
Interfejs USB wspiera filozofię włącz i działaj (ang.
 
\shape italic
\lang british
Plug and Play
\shape default
\lang polish
) wraz z dynamicznym ładowaniem sterowników.
 Użytkownik wpina urządzenie do magistrali i następuje jego automatyczna
 identyfikacja.
 Podobnie, po zakończeniu pracy wystarczy po prostu odłączyć urządzenie
 i nastąpi automatyczna identyfikacja odpięcia z magistrali.
 Ładowanie i usuwanie z pamięci sterowników urządzenia następuje automatycznie.
 Przy pierwszym ładowaniu sterowników system operacyjny może zażądać wskazania
 fizycznej lokalizacji plików sterownika urządzenia.
 Identyfikacja urządzeń następuje poprzez dwa numery identyfikacyjne PID
 (ang.
 
\shape italic
\lang british
Product IDentification
\shape default
\lang polish
 -- identyfikator produktu) i VID (ang.
 
\shape italic
\lang british
Vendor IDenticifation
\shape default
\lang polish
 -- identyfikator producenta).
 Uzyskanie numeru producenta wymaga wykupienia licencji od USB Implementation
 Forum
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Szczegóły dotyczące rejestracji numeru producenta (ang.
 
\shape italic
\lang british
Vendor ID
\shape default
\lang polish
) można znaleźć na stronie: http://www.usb.org/developers/vendor.html.
\end_layout

\end_inset

, co kosztuje od $2000 w górę.
 Jest to poważną barierą dla elektroniki amatorskiej.
\end_layout

\begin_layout Standard
Problem identyfikatorów dla projektów amatorskich korzystających z USB został
 jednak rozwiązany na następujące sposoby:
\end_layout

\begin_layout Itemize
Projektant urządzenia stosujący układ mikrokontrolera z wbudowaną sprzętową
 obsługą USB może wykorzystać numer produktu puli oferowanej przez producenta
 układu.
 Numer producenta będzie wtedy taki sam, jak producent układu scalonego.
 Jest to rozwiązanie dopuszczalne tylko dla produktów niekomercyjnych.
\end_layout

\begin_layout Itemize
Projektant urządzenia planujący rozpowszechniania lub sprzedaż urządzenia
 może skorzystać z usług firm
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Taką ofertę mają między innymi: Mechanique (http://www.mecanique.co.uk), EZPrototyp
es (http:://www.ezprototypes.com), MCS Electronics (http://mcselec.com).
\end_layout

\end_inset

, które zarejestrowały swój identyfikator producenta i odsprzedają pojedyncze
 identyfikatory produktu dla zainteresowanych elektroników lub małych firm,
 których budżet nie pozwala na rejestrację w USB Implementation Forum.
\end_layout

\begin_layout Standard
Oba powyższe rozwiązania nie pozwalają na stosowanie zastrzeżonego logo
 certyfikowanego produktu USB, którego licencja dopuszcza tylko firmy mające
 podpisaną umowę z USB Implementation Forum.
\end_layout

\begin_layout Subsection
Metody implementacji
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Opisać metody implementacji sprzętowej i programowej interfejsu USB.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Popularność interfejsu USB stała się możliwa dzięki wysokiej dostępności
 w układach małych mikrokontrolerów, które trafiały do wszystkich urządzeń
 współpracujących z komputerami przez USB.
 Strategie realizacji obsługi USB przez urządzenia są jednak dwie:
\end_layout

\begin_layout Description
programowa w której układ zawiera wyprowadzenia elektrycznie zgodne ze specyfika
cją USB, a wszystkie elementy stosu są realizowane programowo -- w rezultacie
 prędkość działania tak obsługiwanego USB nie może być wysoka, jest jednak
 efektywna kosztowo i nadaje się doskonale do prostych urządzeń;
\end_layout

\begin_layout Description
sprzętowa polegająca na umieszczeniu jak największej ilości elementów funkcjonal
nych USB w autonomicznych blokach konfigurowalnych przez rejestry mikrokontroler
a i pozwalająca na sięganie do bloków danych w adresowalnej pamięci -- uwalnia
 to rdzeń procesora od zapewnienia prawidłowych warunków pracy, uproszczając
 życie programiście oraz jest jedyną metodą pozwalającą na zapewnianie pełnej
 zgodności dla USB 2.0 wysokiej prędkości.
\end_layout

\begin_layout Standard
Zastosowanie metody programowej wymaga najczęściej zakupu kodu źródłowego
 stosu USB od firmy dostarczającej tego typu rozwiązania.
 Do niektórych mikrokontrolerów dostępne są stosy na otwartych licencjach.
\end_layout

\begin_layout Standard
Realizacja sprzętowa spoczywa na producencie układu, który certyfikuje swój
 produkt jako zgodny ze standardem USB.
 Dzięki temu inżynier projektujący urządzenie ma większą pewność poprawności
 współpracy urządzenia z kontrolerem hosta.
 Wadą jest oczywiście wyższy koszt układu, co w dzisiejszych czasach przestaje
 mieć znaczenie, gdyż uniwersalność USB powoduje, iż powinno być obecne
 w każdym większym urządzeniu.
 W przypadku realizacji sprzętowej łatwiej implementować kontroler hosta,
 a przynajmniej częściową funkcjonalność objętą standardem On-the-Go.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Bluetooth"

\end_inset

Bluetooth
\end_layout

\begin_layout Standard
Technologia Bluetooth oferuje bezprzewodową komunikację krótkiego zasięgu
 pomiędzy urządzeniami elektronicznymi przy niskim zużyciu energii i niskim
 koszcie implementacji.
 Wiele z właściwości Bluetooth opisanych w specyfikacji jest opcjonalnych,
 dzięki czemu wachlarz urządzeń elektronicznych z tą technologią może być
 bardzo zróżnicowany.
\end_layout

\begin_layout Standard
Fizyczna warstwa radiowa Bluetooth działa w nielicencjonowanym paśmie 2,4
\begin_inset space ~
\end_inset

GHz.
 System stosuje szybką zmianę częstotliwości (ang.
 
\shape italic
\lang british
frequency hoping
\shape default
\lang polish
) w celu zapobiegania interferencjom, zanikaniu i odbiciu oraz wykorzystuje
 wiele nośnych w technice FHSS (ang.
 
\shape italic
\lang british
frequency hoping spread spectrum
\shape default
\lang polish
).
 Tor radiowy działa z użyciem kształtowanej binarnej modulacji częstotliwości
 w celu znacznej redukcji złożoności transcivera.
 Konstrukcja pozwala na przesłanie 1 miliona symboli na sekundę, co pozwala
 na transfer danych z prędkością 1
\begin_inset space ~
\end_inset

MBit/s w trybie Basic Rate i nawet do 3
\begin_inset space ~
\end_inset

MBit/s w trybie Enhanced Data Rate.
\end_layout

\begin_layout Standard
Podczas normalnej pracy fizyczny kanał radiowy jest dzielony przez grupę
 urządzeń zsynchronizowanych do wspólnego zegara i wzorca zmian częstotliwości.
 Jedno z urządzeń nadaje referencyjny sygnał synchronizacyjny i jest uznawane
 za nadrzędne.
 Wszystkie pozostałe urządzenia określane są jako podrzędne.
 Grupa zsynchronizowanych w ten sposób urządzeń określana jest jako 
\shape italic
\lang british
piconet
\shape default
\lang polish
.
 Jest to podstawowa forma komunikacji w technologii Bluetooth.
\end_layout

\begin_layout Standard
Urządzenia w piconet używają specyficznego wzorca zmian częstotliwości,
 które są określane na podstawie algorytmu z pewnych pól w adresie Bluetooth
 oraz czasu urządzenia nadrzędnego.
 Podstawową wzorcem dla zmian częstotliwości jest pseudolosowy układ 79
 częstotliwości w paśmie ISM
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
ang.
 
\shape italic
\lang british
industrial, scientific and medical radio bands
\shape default
\lang polish
 -- wybór pasm częstotliwości radiowych określonych dla przemysłu, medycyny
 i nauki do celów innych niż komunikacja; aktualnie stosowanych w nielicencjonow
anych urządzeniach komunikacyjnych odpornych na zakłócenia
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
dopisać źródła specyfikacji...
\end_layout

\end_inset


\end_layout

\end_inset

.
 Wzorzec ten może być adaptacyjnie dostosowany do warunków interferencji
 przez usuwanie częstotliwości o złych parametrach.
 Technika adaptacyjnej zmiany częstotliwości poprawia współistnienie Bluetooth
 z innymi urządzeniami w pasmie ISM, gdy pracują w jednym otoczeniu.
 
\end_layout

\begin_layout Standard
Kanał fizyczny jest podzielony na sloty czasowe.
 Dane są transmitowane pomiędzy urządzeniami Bluetooth w paczka, które są
 umiejscawiane w tych slotach.
 Pewna liczba kolejnych slotów może być przydzielona dla pojedynczego pakietu,
 gdy warunki na to pozwalają.
 Zmiany częstotliwości następują pomiędzy nadaniem lub odbiorem pojedynczych
 pakietów.
 Technologia Bluetooth pozwala na transmisję z pełnym dupleksem dzięki zastosowa
niu schematu TTD (ang.
 
\shape italic
\lang british
Time-Division Duplex
\shape default
\lang polish
 -- dupleks z podziałem czasu).
\end_layout

\begin_layout Subsection
Architektura rdzenia Bluetooth
\end_layout

\begin_layout Standard
Rdzeń systemu Bluetooth pokrywa cztery warstwy i powiązane z nimi protokoły
 zdefiniowane w specyfikacji, jak również jedną wspólną warstwę serwisów
 SDP (ang.
 
\shape italic
\lang british
Service Discovery Protocol
\shape default
\lang polish
) oraz ogólne wymagania profili określone w GAP (ang.
 
\shape italic
\lang british
Generic Access Profile
\shape default
\lang polish
).
 Kompletna aplikacja Bluetooth wymaga wielu dodatkowych serwisów i protokołów
 warstwy wyższej określonych w specyfikacji Bluetooth ale nie opisanych
 tutaj.
 Architektura rdzenia jest pokazana na rysunku 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(blabla rysunek do wymachania)
\end_layout

\end_inset

 nie obejmującym SDP, który nie jest pokazany dla zachowania przejrzystości.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Obrazek stosu...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Trzy najniższe warstwy są czasem grupowane w podsystem określany jako kontroler
 Bluetooth.
 To jest potoczna implementacja obejmująca standardowy interfejs komunikacyjny
 pomiędzy kontrolerem i resztą systemu Bluetooth z włączeniem L2CAP (ang.
 
\shape italic
\lang british
Logical Link Control and Adaptation Protocol
\shape default
\lang polish
), serwisów i warstw wyższych -- określanych jako host Bluetooth.
 Aczkolwiek ten interfejs jest opcjonalny, architektura jest zaprojektowana
 aby umożliwi jego istnienie i charakterystykę.
 Specyfikacja umożliwia współdziałanie pomiędzy niezależnymi systemami Bluetooth
 poprzez zdefiniowanie wiadomości protokołu wymienianych na poziomie odpowiadają
cych sobie warstw, jak również współdziałanie pomiędzy niezależnymi podsystemami
 poprzez zdefiniowanie wspólnego interfejsu pomiędzy kontrolerem a hostem.
\end_layout

\begin_layout Chapter
Mikrokontrolery
\end_layout

\begin_layout Standard
Rozdział opisuje wybrane konstrukcje mikrokontrolerów oferowanych przez
 różnych producentów, których wybór rozważano do zastosowania w projekcie.
 Opis obejmuje szczegóły techniczne konstrukcji oraz aspekty inżynierskie
 związane z zastosowaniem opisywanych układów w praktyce.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ARM"

\end_inset

ARM Limited
\end_layout

\begin_layout Standard
Firma ARM Limited z siedzibą w Wielkiej Brytanii, nie jest producentem układów
 scalonych mikroprocesorów, lecz zajmuje się projektowaniem rdzeni procesorów
 oraz sprzedażą własności intelektualnej do tych projektów firmom trzecim,
 głównie uznanym producentom układów mikroprocesorowych, o których mowa
 w tym rozdziale.
 Rdzenie serii ARM w kolejnych wcieleniach cieszą się ogromną popularnością
 producentów urządzeń codziennego użytku potrzebujących wysokich wydajności,
 takich jak telefony komórkowe, przenośne odtwarzacze DVD oraz wiele innych.
 Procesory z rdzeniem ARM stanowią około 3/4 rynku sprzedaży dla 32 bitowych
 układów.
\end_layout

\begin_layout Standard
Stosowana w tej chwili nazwa ARM jest akronimem od angielskich słów 
\shape slanted
Advanced RISC Machine
\shape default
, a wcześniej 
\shape slanted
Acorn RISC machine
\shape default
.
 Historia tych procesorów sięga roku 1983, gdy brytyjska firma Acorn Computers
 pracowała nad nowym procesorem dla swoich komputerów.
 Znaczenie komputerów Acorn na brytyjskim rynku w owym czasie, przypominało
 tryumfy komputerów Apple w Stanach Zjednoczonych.
 W latach odpowiednio 1985 i roku następnym, Acorn prezentuje kolejno procesory
 ARM1 i ARM2.
\end_layout

\begin_layout Standard
Cechą szczególną całej rodziny procesorów ARM, w tym również odgałęzień
 jest zestaw instrukcji maszynowych łączących pewne zestawy operacji często
 pojawiających się w kodzie napisanych w językach wyższego poziomu.
 Dzięki czemu, skompilowany kod binarny jest bardzo mały i może być wykonywany
 szybko, mimo niskich częstotliwości zegarów taktujących pracę rdzenia procesora.
 Zachowano przy tym mechanizmy z procesorów RISC, gwarantujące stałą długość
 rozkazu.
 ARM dodatkowo rozszerzyła możliwości rdzeni o technologie 
\shape smallcaps
Thumb
\shape default
, 
\shape smallcaps
Thumb-2
\shape default
 i 
\shape smallcaps
Neon
\shape default
 -- w szczególności ta ostatnia znalazła zastosowanie w implementacji kodeków
 głosowych w telefonach GSM.
\end_layout

\begin_layout Standard
Z architektury ARM wywodzą się takie rodziny procesorów, jak XScale firmy
 Intel -- znajdujący zastosowanie w wielu PDA -- oraz OMAP firmy Texas Instrumen
ts -- wielordzeniowe procesory multimedialne.
\end_layout

\begin_layout Subsection
ARM 6
\end_layout

\begin_layout Standard
Rdzeń ARM6 jest wart wzmiankowania z racji historycznej roli, jaką jego
 implementacja oznaczona ARM610 odegrała w świecie palmtopów.
 Realizacja procesora ujrzała światło dzienne w 1990 roku.
 W roku 1993 firma Apple rozpoczęła sprzedaż Apple Newton Message Pad --
 produktu wyprzedzającego o epokę wymagania użytkowników.
 Z racji niewielkiej popularności, po opracowaniu siedmiu modeli Apple Newton,
 sprzedaż zakończyła się w 1998 roku.
\end_layout

\begin_layout Standard
Implementacje architektury ARM6 w postaci układów ARM600 i ARM610 były jeszcze
 produktami firmy ARM Limited, produkowanym w fabrykach VLSI Technologies
 Inc.
 Na bazie licencji DEC stworzył pierwszy procesor StrongARM.
 Ten projekt następnie w roku 1997 na skutek realizacji warunków umowy trafił
 pod skrzydła Intel'a, by później przekształcić się w linię procesorów XScale
\begin_inset CommandInset citation
LatexCommand cite
key "cnet-intel-digital-1997"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:ARM-7"

\end_inset

ARM 7
\end_layout

\begin_layout Standard
Rdzeń ARM7 jest obecny na rynku od 1993.
 Do dnia dzisiejszego pełni istotną rolę w tworzeniu wielu specjalizowanych
 układów sterujących do urządzeń.
 W 1994 roku dochodzi wersja ARM7TDMI, w której pojawia się rozszerzenie
 Thumb oraz sprzętowe wsparcie dla cyfrowego przetwarzania sygnałów (ang.
 
\shape italic
\lang british
digital signal processing
\shape default
\lang polish
).
 Do zastosowań dopasowanych do potrzeb produktów, rdzenie ARM7TDMI-S i ARM7EJ-S
 są w pełni syntetyzowalne w układach programowalnych, które pozwala na
 konstruowanie układów scalonych w pełni dostosowanych do potrzeb produktu,
 w których mają być stosowane.
\end_layout

\begin_layout Standard
Gwarantowaną przez autorów cechą rdzeni ARM7 jest pełna przenoszalność kodu
 na rdzenie nowszego typu, w szczególności ARM 9 i Cortex.
 Rdzeń ARM7EJ-S zawiera też wsparcie dla technologii Jazelle opisanej w
 podrozdziale
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Jazelle"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:ARM-9"

\end_inset

ARM 9
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Jazelle"

\end_inset

Jazelle
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "34mm"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/jazelle_logo.png
	lyxscale 30
	width 30mm

\end_inset


\end_layout

\end_inset

Technologia Jazelle DBX (skrót od ang.
 
\shape italic
\lang british
Direct Bytecode eXecution
\shape default
\lang polish
) została opracowana przez ARM w celu przyspieszania sprzętowego pewnych
 operacji bajt-kodu maszyny wirtualnej Java (w skrócie JVM).
 Pozwala ona wykonywać bajt-kod Javy, jakby był on natywnym kodem procesora.
 Sprzętowa implementacja Jazelle DBX wykonana jest na około 12 tysiącach
 bramek, co oznacza niski koszt implementacji wewnątrz układu.
 Liczba ta jest znacząco mniejsza od liczby bramek typowego koprocesora
 matematycznego.
\end_layout

\begin_layout Standard
Takie podejście wzmocnione przez technologię Jazelle RCT (ang.
 
\shape italic
\lang british
Runtime Compilation Target
\shape default
\lang polish
), która wspiera kompilację 
\shape slanted
\lang british
ahead-of-time
\shape default
\lang polish
 (AOT) i 
\shape slanted
\lang british
just-in-time
\shape default
\lang polish
 (JIT), pozwala znacząco zwiększyć wydajność aplikacji Java w urządzeniach
 przenośnych, głównie telefonach komórkowych.
 Aktualne możliwości technologii Jazelle RCT sięgają dużo dalej, wspierając
 kompilację i wykonywanie kodu takich platform jak Microsoft.NET, Perl czy
 Python.
 Implementację tej technologii wspierają wszystkie mikroprocesory z rodziny
 ARM Cortex-A
\begin_inset CommandInset citation
LatexCommand cite
key "jazelle-wp"

\end_inset

.
\end_layout

\begin_layout Section
Freescale Semiconductor
\end_layout

\begin_layout Standard
Firma Freescale Semiconductor
\begin_inset Foot
status open

\begin_layout Plain Layout
Strona producenta: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.freescale.com
\end_layout

\end_inset

.
\end_layout

\end_inset

 to korporacja powstała z wydzielenia działu układów scalonych firmy Motorola.
 Układy scalone Motoroli od kilkudziesięciu lat mają uznaną pozycję na rynku
 elektroniki cyfrowej, a udział Motoroli w konsorcjum tworzącym rdzeń PowerPC
 odcisnął duże piętno na tej architekturze.
\end_layout

\begin_layout Standard
Warto również dodać, iż pod koniec lat '80 assembler rodziny mikroprocesorów
 6800 był w Polsce bardzo popularny.
 Procesory te znalazły się w popularnych komputerach Amiga oraz były stosowane
 w wielu urządzeniach.
 Wartość programów w assemblerze dla tych układów była bardzo wysoka, a
 kompilatory języków wysokiego poziomu obarczone były dużym nakładem na
 kodzie wynikowym.
 Osiąganie dobrych wyników w programach graficznych i grach na komputerze
 Amiga osiągano dzięki fragmentom programów pisanych w assemblerze.
\end_layout

\begin_layout Standard
Firma Motorola w latach 1991--2004 wraz z IBM i Apple brała udział w pracach
 konsorcjum tworzącym rdzeń PowerPC.
 W roku 2006, gdy firma Apple zrezygnowała oficjalnie z architektury PowerPC
 na rzecz produktów firmy Intel, konsorcjum zmieniło swój kształt.
 Od 2004 roku, gdy Freescale został wydzielony jako osobny podmiot biznesowy
 z Motoroli, nadal pracował nad udoskonalaniem architektury PowerPC, natomiast
 wycofanie się Apple sprawiło, że świetny skądinąd PowerPC G5 był ostatnim
 układem zastosowanym w popularnych komputerach użytkowych.
 
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "2cm"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/logo_power_org_black.gif
	lyxscale 50
	width 2cm

\end_inset


\end_layout

\end_inset

Aktualnie firmy współpracujące nad architekturą związane są z Power.org
\begin_inset Foot
status open

\begin_layout Plain Layout
Istniejąca od 2004 roku, utworzona przez IBM fundacja na rzecz architektury
 
\shape smallcaps
Power
\shape default
, jej adres internetowy: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.power.org
\end_layout

\end_inset

.
\end_layout

\end_inset

.
 Organizacja ta zrzesza ponad 40 firm z branży elektroniki i oprogramowania,
 między innymi IBM, Freescale, Synopsys, Cadence, Mentor Graphics, Wind
 River, Xilinx.
 Głównym jej celem jest promowanie platformy dla nowych rozwiązań i wspólne
 badanie nad rozwojem 
\shape smallcaps
Power Architecture
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "power.org-vision"

\end_inset

.
\end_layout

\begin_layout Standard
Firma Freescale posiada cztery rodziny mikroprocesorów 32 bitowych, opisane
 krótko w kolejnych podrozdziałach.
\end_layout

\begin_layout Subsection
PowerQUICC
\end_layout

\begin_layout Standard
Układy zaawansowanych mikrokontrolerów na bazie konstrukcji PowerPC rozwijane
 od 1995 roku.
 Cechą szczególną linii PowerQUICC jest wbudowany zaawansowany podsystem
 kontroli komunikacyjnej, odciążającej główny rdzeń układu.
 Dzięki temu nadają się do zastosowań w systemach telekomutacyjnych, takich
 jak routery lub centrale telefoniczne.
 Seria układów PowerQUICC I oznaczana przez symbole MPC8xx były pierwszymi
 układami z rodziny PowerPC produkowanymi przez Motorolę.
 Różnorodne wersje układów różniły się dokładanym wyposażeniem, konfiguracją
 ilości potoków, pamięci cache, obsługiwanymi interfejsami.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement th
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename vector/mpc885-block-diagram.svg
	lyxscale 20
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schemat blokowy MPC885.
\end_layout

\end_inset


\end_layout

\end_inset

W roku 1998 pojawiły się układy z linii PowerQUICC II oznaczane symbolami
 MPC82xx bazowane na procesorze PowerPC 603e znanym też jako G2 (pojawiły
 się w komputerach firmy Apple).
 Wersja od Motoroli trafiała do stacji bazowych telefonii komórkowej, przełączni
ków sieciowych i multiplekserów obsługujących abonenckie linie cyfrowe
\begin_inset Foot
status open

\begin_layout Plain Layout
Abonencka linia cyfrowa (ang.
 
\shape italic
\lang british
Digital Subscriber Line
\shape default
\lang polish
, DSL) stosowana w telekomunikacji naziemnej do oferowania szybkich łącz
 Internetowych; multiplekser dostępowy DSL to urządzenie pozwalające na
 obsługę sygnału cyfrowego na analogowych liniach abonenckich.
\end_layout

\end_inset

.
 Seria ta została całkowicie zastąpiona przez linię PowerQUICC II Pro produkowan
ą od roku 2004.
\end_layout

\begin_layout Standard
Linia PowerQUICC II Pro bazowała na rozbudowanym rdzeniu, którego pamięć
 cache została zwiększona do 32kB dla instrukcji i 32kB dla danych oraz
 zwiększono maksymalne taktowanie rdzenia.
 Oznaczano ją symbolami MPC83xx, przy czym dodatkowa litera E symbolizowała
 wbudowaną jednostkę szyfrującą.
 Układy te trafiły do urządzeń produkowanych przez firmę Cisco.
\end_layout

\begin_layout Standard
Od roku 2003 firma Freescale oferuje układy z linii PowerQUICC III oparte
 o rdzeń e500, który nie ma odpowiednika w procesorach PowerPC ogólnego
 zastosowania.
 Oznaczane symbolami MPC85xx układy są specjalizowanymi procesorami komunikacyjn
ymi, zdolnymi obsługiwać wiele portów Gigabit Ethernet jednocześnie, co
 czyni je doskonałymi procesorami dla szybkich przełączników.
 W tej linii są układy wielordzeniowe.
\end_layout

\begin_layout Standard
Firma Freescale wspiera projektowanie dla procesorów linii PowerQUICC bogatym
 zestawem narzędzi, w tym środowiskiem CodeWarrior.
 Narzędzia te są jednak są bardzo drogie.
 Testowe wersje tego oprogramowania mają okrojone możliwości i nie są popularne
 wśród amatorów.
\end_layout

\begin_layout Subsection
ARM
\end_layout

\begin_layout Standard
W rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ARM"

\end_inset

 opisane są osiągnięcia firmy ARM w projektowaniu i sprzedaży projektów
 rdzeni mikroprocesorów dla innych firm produkujących układy scalone procesorów
 i mikrokontrolerów.
\end_layout

\begin_layout Subsection
68K/ColdFire
\end_layout

\begin_layout Standard
Rodzina 68K jest najbardziej znaną rodziną mikroprocesorów firmy Motorola,
 a aktualnie Freescale Semiconductor.
 Model MC68000 debiutował w 1979 roku i mocno zmodyfikowany jest produkowany
 do dnia dzisiejszego.
 Najmocniejszy typ układu w rodzinie MC68060 jest również nadal produkowany
 w kilku odmianach.
 Procesory te znalazły zastosowane w komputerach Atari i Amiga oraz wielu
 urządzeniach powszechnego użytku.
\end_layout

\begin_layout Standard
Układy ColdFire są przekształconą wersją układów rodziny 68K dla zastosowań
 w systemach wbudowanych.
 Są wielokrotnie szybsze niż ich oryginalne odpowiedniki, pracują z częstotliwoś
cią do 300 MHz (w porównaniu z 60 MHz dla MC68060).
 Aktualna zgodność binarna układów ColdFire sprawia, że grupy zapaleńców
 konstruują klony komputerów Atari i Amiga.
 Istnieją również porty systemu Linux dla układów z rodziny 68K
\begin_inset Foot
status open

\begin_layout Plain Layout
Więcej informacji na stronie 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.linux-m68k.org
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ostatnia wersja rdzenia ColdFire oznaczana jako V5 jest rdzeniem superskalarnym,
 przy czym do dziś firma Freescale nie rozpoczęła sprzedaży układów z tej
 rodziny.
 Produkowane i sprzedawane układy posiadają nadal rdzeń oznaczany jako V4,
 który nie jest jeszcze w pełni superskalarny.
\end_layout

\begin_layout Subsection
MCORE
\end_layout

\begin_layout Standard
Rodzina MCORE to kilka układów 32-bitowych zaprojektowanych specjalnie do
 specyficznych zastosowań przemysłowych i medycznych.
 Głównym kryterium branym pod uwagę przy konstrukcji tych procesorów była
 energooszczędność oraz obsługa specyficznych interfejsów przydatnych w
 przemyśle (np.
 PWM, ang.
 
\shape italic
\lang british
Pulse Width Modulation
\shape default
\lang polish
).
\end_layout

\begin_layout Section
Atmel Corporation
\begin_inset CommandInset label
LatexCommand label
name "sec:Atmel-Corporation"

\end_inset


\end_layout

\begin_layout Standard
Firma Atmel Corporation oferuje wiele różnych konstrukcji procesorów, z
 których najpopularniejsze to cała rodzina mikrokontrolerów AVR -- 8 bitowych
 układów o architekturze RISC, ciesząca się ogromną popularnością wśród
 amatorów.
 Wiele projektów elektronicznych dostępnych w internecie opartych jest właśnie
 o układy z tej rodziny.
 Oprócz tego Atmel oferuje szeroką gamę układów opartych o rdzeń ARM.
\end_layout

\begin_layout Subsection
AVR
\begin_inset CommandInset label
LatexCommand label
name "sub:AVR-serie"

\end_inset


\end_layout

\begin_layout Standard
Utarło się przekonanie, że podstawowa architektura AVR została opracowana
 przed dwóch studentów Norweskiego Instytutu Technologii (nor.
 
\shape italic
\lang norsk
Norges Tekniske Høgskole
\shape default
\lang polish
, w skrócie NTH).
 Nazywają się Alf-Egil Bogen i Vegard Wollan.
\end_layout

\begin_layout Standard
W rzeczywistości oryginalny mikrokontroler został opracowany w Trondheim
 w Norwegii, gdzie dwóch przyszłych fundatorów norweskiego oddziału firmy
 Atmel odbywało praktyki studenckie.
 Był znany jako μRISC.
 Kiedy technologia została sprzedana do firmy Atmel, jego wewnętrzna architektur
a była dalej rozwijana przez Alfa i Vegarda w norweskim oddziale firmy.
\end_layout

\begin_layout Standard
Oficjalne stanowisko w sprawie nazwy AVR mówi, że nie jest to ani akronim,
 ani nie oznacza niczego innego poza nazwą własną.
 Twórcy AVR nie dają jednoznacznej odpowiedzi, co do znaczenia terminu 
\begin_inset Quotes pld
\end_inset

AVR
\begin_inset Quotes prd
\end_inset

.
 Nazwa AVR stosowana tutaj odnosi się do 8-bitowej linii mikrokontrolerów
 RISC, niezależnie od wzmiankowanej dalej nazwy AVR32.
\end_layout

\begin_layout Standard
Pierwszym produktem w rodzinie był AT90S8515 w 40-nóżkowej obudowie DIP,
 posiadał identyczny układ wyprowadzeń jak popularny 8051, włączając w to
 zewnętrzną multipleksację szyny adresowej i danych.
 Polaryzacja nóżki resetującej była odwrotna (8051 miał aktywny stan wysoki,
 AVR -- stan niski), lecza poza tym układ wyprowadzeń był całkowicie zgodny.
\end_layout

\begin_layout Standard
W rodzinie AVR do dziś są oferowane układy zaklasyfikowane do następujących
 kategorii:
\end_layout

\begin_layout Description
ATtiny składa się z układów o bardzo małej liczbie wyprowadzeń, które służą
 do realizacji projektów o dużej miniaturyzacji i bardzo ograniczonej funkcjonal
ności, jak proste układy kontrolno-sterujące; nie posiadają wyprowadzeń
 szyny adresowej na zewnątrz układu i cechują się niewielkimi ilościami
 pamięci.
\end_layout

\begin_layout Description
ATmega jest to rodzina układów o bardziej rozbudowanej konstrukcji wewnętrznej
 z wyprowadzoną większą ilością lini wejścia-wyjścia, dostępne z różnymi
 konfiguracjami wewnętrznej pamięci Flash.
\end_layout

\begin_layout Description
ATxmega jest grupą która zmienia sposób mapowania elementów rdzenia, jakich
 jak rejestry wewnętrzne, pamięć EEPROM, w kilku modelach możliwe jest adresowan
ie pamięci SDRAM.
 Mogą posiadać też DMA, bogaty zestaw przetworników cyfrowo-analogowych,
 jak też sprzętowe wsparcie dla kryptografii.
\end_layout

\begin_layout Description
FPSLIC to połączenie rdzenia AVR z logiką programowalną FPGA w jednym układzie
 scalonym.
\end_layout

\begin_layout Subsection
AVR32
\begin_inset CommandInset label
LatexCommand label
name "sub:AVR32-serie"

\end_inset


\end_layout

\begin_layout Standard
AVR32 to rodzina 32 bitowych mikrokontrolerów produkcji firmy Atmel
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Strona układów AVR32 u producenta: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.atmel.com/products/avr32/
\end_layout

\end_inset


\end_layout

\end_inset

 Oferowane są układy z dwóch głównych odmianach: 
\end_layout

\begin_layout Description
UC3 lżejszej odmianie mikrokontrolera dla dla mocno zintegrowanych rozwiązań
 o niskim poborze energii do kontroli i sterowania, 
\end_layout

\begin_layout Description
AP7 odmianie wysokowydajnych mikrokontrolerów dla zaawansowanych multimedialnych
 aplikacji przenośnych, mogący między innymi pracować pod kontrolą systemu
 operacyjnego Linux.
 
\end_layout

\begin_layout Standard
Istotną przewagą oferty firmy Atmel i układów AVR32 nad układami innych
 producentów jest bardzo silne wsparcie dla amatorów oraz środowiska otwartego
 oprogramowania.
\begin_inset Float figure
placement th
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/avr32-block-diagram.svg
	lyxscale 50
	width 99text%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-blokowy-AVR32"

\end_inset

Schemat blokowy AVR32 UC3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
\begin_inset CommandInset label
LatexCommand label
name "sub:Mikrokontroler-AT32UC3A0512"

\end_inset

Mikrokontroler AT32UC3A0512
\end_layout

\begin_layout Standard
Układ AT32UC3A jest kompletnym systemem-w-układzie na bazie 32-bitowego
 rdzenia AVR32 UC typu RISC działającym z
\begin_inset space ~
\end_inset

częstotliwością do 66
\begin_inset space ~
\end_inset

MHz.
 Rdzeń tego typu został zaprojektowany w celu redukcji kosztów aplikacji
 wbudowanych ze szczególnym naciskiem na niskie zużycie mocy, wysoką gęstość
 kodu i wysoką wydajność.
\end_layout

\begin_layout Standard
Układ posiada jednostkę ochrony pamięci (MPU) oraz szybki i elastyczny kontroler
 przerwań wspierający nowoczesne systemy operacyjne i systemy operacyjne
 czasu rzeczywistego.
 Wysoka wydajność obliczeniowa jest osiągalna dzięki bogatemu zestawowi
 instrukcji DSP.
\end_layout

\begin_layout Standard
Układ AT32UC3A0512 zawiera wewnętrzną pamięć Flash i pamięć statyczną dla
 bezpiecznego i szybkiego dostępu.
 Aplikacje wymagające większej dodatkowej pamięci mogą skorzystać z interfejsu
 zewnętrznej pamięci dynamicznej.
 Kontroler peryferyjnego bezpośredniego dostępu do pamięci (PDCA) umożliwia
 transfer danych pomiędzy peryferiami a pamięcią bez angażowania procesora.
 PDCA drastycznie redukuje koszty transferu ciągłych i wielkich strumieni
 danych pomiędzy modułami wewnątrz mikrokontrolera.
\end_layout

\begin_layout Standard
Układ zarządzania zasilaniem PowerManager udoskonala elastyczność projektu
 i bezpieczeństwo -- wykrywa zaniki zasilania.
 Mikrokontroler może być taktowany z wewnętrznego oscylatora RC lub z jednego
 z zewnętrznych oscylatorów, zegar czasu rzeczywistego i powiązany z nim
 timer utrzymują pomiar czasu.
 Timery/Liczniki to 3 kanały 16-bitowe.
 Każdy kanał jest programowany niezależnie do pomiaru częstotliwości, zliczania
 zdarzeń, generacji impulsów, pomiaru opóźnień i modulacji szerokości impulsów.
\end_layout

\begin_layout Standard
Moduły PWM dostarczają siedem niezależnych kanałów z wieloma opcjami konfiguracy
jnymi włączając polaryzację
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Przez polaryzację sygnału PWM należy rozumieć ustalenie, czy bazowym poziomem
 jest logiczny stan niski, czy logiczny stan wysoki, nie zaś ujemna lub
 dodatnia wartość potencjału elektrycznego wyjścia.
\end_layout

\end_inset

, wyrównanie krawędzi i niezachodzenie sygnału.
 Jeden z kanałów może wyzwalać przetwornik analogowo\SpecialChar \nobreakdash-
cyfrowy, dzięki czemu
 możliwe są bardziej dokładne implementacje z zamknięta pętlą.
 Układ AT32UC3A jest wyposażony w wiele interfejsów komunikacyjnych dla
 wymagających intensywnej komunikacji aplikacji.
 Poza standardowymi interfejsami szeregowymi typu UART, SPI lub TWI, dostępne
 są inne interfejsy jak elastyczny kontroler synchroniczny (ang.
 
\shape italic
\lang british
Synchronous Serial Controller
\shape default
\lang polish
), USB i Ethernet MAC.
 Kontroler synchroniczny udostępnia łatwy dostęp do protokołów komunikacji
 szeregowej i standardów audio takich, jak I
\begin_inset Formula $^{2}$
\end_inset

S.
 Interfejs USB 2.0 
\lang british
Full-Speed
\lang polish
 wspiera wiele klas USB jednocześnie dzięki bogatej konfiguracji punktu
 końcowego.
 Wsparcie dla hosta standardu 
\lang british
On\SpecialChar \nobreakdash-
The\SpecialChar \nobreakdash-
Go
\lang polish
 (OTG) pozwala podłączać bezpośrednio do mikrokontrolera urządzenia typu
 dysk flash USB lub drukarkę USB.
 Interfejs MII (ang.
 
\shape italic
\lang british
media independent interface
\shape default
\lang polish
) oraz RMII (ang.
 
\shape italic
\lang british
reduced media independent interfac
\shape default
\emph on
\lang polish
e
\emph default
) modułu MAC Ethernet dla prędkości 10 i 100 Mbps udostępnia rozwiązania
 wewnątrzukładowe dla urządzeń przyłączanych do sieci.
 AT32UC3A integruje debugowanie w układzie OCD (ang.
 
\shape italic
\lang british
On\SpecialChar \nobreakdash-
Chip
\begin_inset space ~
\end_inset

Debug
\shape default
\lang polish
) klasy drugiej typu Nexus 2.0, pozwalający na bezinwazyjne śledzenie wykonania
 programu w czasie rzeczywistym, zapis i odczyt pamięci z pełną prędkością
 w połączeniu do podstawowej kontroli wykonywania programu.
\end_layout

\begin_layout Subsection
ARM
\end_layout

\begin_layout Standard
Układy serii AT91SAM cieszą się coraz większą popularnością, są bardzo dobrze
 udokumentowane przez producenta, który również dostarcza do nich bogatą
 bibliotekę kodu do obsługi wbudowanych w układ interfejsów.
 Dzięki temu implementacje wielu zastosowań tej serii procesorów zajmują
 mniej czasu.
 Ciekawe konstrukcje płyt ewaluacyjnych dla tych układów czynią produkty
 firmy Atmel najciekawszymi w rodzinie układów z rdzeniem ARM.
\end_layout

\begin_layout Standard
Grupy układów AT91SAM7S, AT91SAM7SE, AT91SAM7X oparte są o rdzeń ARM 7 opisany
 w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ARM-7"

\end_inset

.
 Poszczególne wersje różnią się dostępnymi interfejsami oraz wielkościami
 wbudowanej pamięci.
 Układy serii AT91SAM9 bazują na rdzeniu ARM 9 opisanym w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ARM-9"

\end_inset

.
\end_layout

\begin_layout Section
Analog Devices
\end_layout

\begin_layout Standard
Istniejąca od 1965 roku firma Analog Devices zajmuje się projektowaniem
 i produkcją złożonych układów scalonych dla techniki analogowej i cyfrowej.
 Oprócz uznanych wzmacniaczy i przetworników analogowo-cyfrowych, firma
 produkuje różnego rodzaju sensory (w tym linowy sensor przyspieszenia ADXL3300
 zastosowany w konsoli do gier Wii firmy Nitendo
\begin_inset CommandInset citation
LatexCommand cite
key "ad-wii-sensor"

\end_inset

) oraz znaną rodzinę procesorów Blackfin, stosowaną w wielu urządzeniach
 firm takich jak Hitachi czy Roland.
\end_layout

\begin_layout Subsection
Blackfin
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "2cm"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/BF_chip_100x100.jpg
	width 2cm

\end_inset


\end_layout

\end_inset

Mikroprocesory z rdzeniem Blackfin to 16- lub 32-bitowe układy w architekturze
 RISC.
 Potok przetwarzania jest 10 etapowy, a konstrukcje jednostek arytmetycznych,
 stawiają architekturę Blackfin wśród procesorów DSP.
 Pełne wsparcie SIMD pozwala na wydajne przetwarzanie multimedialne obrazu
 wideo oraz dźwięku.
 Procesor ten powstał jako rozwinięcie starszej architektury SHARC firmy
 Analog Devices i architektury XScale firmy Intel.
 Wewnętrzna budowa układów Blackfin oparta jest o architekturę harvardzką.
 Dwie 16-bitowe jednostki MAC, dwie 40-bitowe jednostki arytmetyczno-logiczne,
 dwie 40-bitowe 
\begin_inset Note Note
status open

\begin_layout Plain Layout
tłumaczenie:
\end_layout

\end_inset

<barrel shifter> pozwalają wykonać do trzech instrukcji w jednym cyklu zegara,
 przy odpowiedniej optymalizacji.
 Lokuje to procesory Blackfin w rodzinie DSP.
 Ochrona pamięci (MPU), różne poziomy operacji (użytkownik, jądro), operacje
 jednocyklowe, pamięć podręczna instrukcji i danych oraz zestaw instrukcji
 do testów bitu, dostępu do bajtu, słowa lub liczby całkowitej i do zintegrowany
ch "peryferiów" czynią ten układ procesorem RISC.
 Lista instrukcji (16-bitowych dla zwykłych operacji i 32- lub 64-bitowych
 dla operacji DSP) tego procesora obejmuje bardzo złożone operacje, co czyni
 skompilowany kod binarny bardzo wydajnym i wysoce zoptymalizowanym.
 Do wad układów Blackfin trzeba zaliczyć brak jednostki zarządzania pamięcią
 (MMU) i obsługi wirtualizacji.
 Układ ten najczęściej jest stosowanych w urządzeniach audio-video do użytku
 codziennego oraz w profesjonalnych urządzeniach wysokiej jakości przetwarzający
ch dźwięk lub obraz.
 
\end_layout

\begin_layout Subsection
TigerSHARC
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "2cm"
status collapsed

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/TS_chip_100x100.jpg
	width 2cm

\end_inset


\end_layout

\end_inset

Procesory TigerSHARC są podobnie jak układy Blackfin połączeniem konstrukcji
 DSP z wydajną architekturą RISC, jednakże ogromny nacisk położono na architektu
rę wieloprocesorową.
 Bardzo duża wewnętrzna pamięć pozwala przetwarzać FFT nawet do 64.000 punktów,
 a bardzo szybkie szyny wewnętrzne i zewnętrzne pozwalają uzyskiwać ogromne
 moce przetwarzania strumieni danych.
\end_layout

\begin_layout Standard
Układy te są stosowane szeroko w urządzeniach infrastruktury telefonii 3G
 oraz w militarnych systemach obronnych, na przykład radarach lotniczych.
\end_layout

\begin_layout Subsection
SHARC
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "2cm"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/sharc_chip_100x100.jpg
	width 2cm

\end_inset


\end_layout

\end_inset

Układy SHARC (nazwa od ang.
 
\shape italic
\lang british
Super Harvard Architecture Single-Chip Computer
\shape default
\lang polish
) to wydajne procesory DSP o architekturze RISC, których pierwsze konstrukcje
 sięgają roku 1994.
 Są wzorcem dla nowszych układów TigerSHARC i Blackfin.
\end_layout

\begin_layout Standard
Szerokość słowa rozkazu tych procesorów do 48 bitów, a liczby całkowitej
 i pojedynczej precyzji 32 bity.
 Rozszerzona obsługa liczb zmiennoprzecinkowych rozszerzona jest do 40 bitów.
 SHARC nie posiada wbudowanego MMU.
 Dwa identyczne zestawy rejestrów ogólnego stosowania pozwalają na realizację
 bardzo szybkiego przełączania kontekstu.
 Współpraca pomiędzy wieloma procesorami w systemie może być realizowana
 szeregowo, gdyż SHARC oferują wiele niezależnych interfejsów szeregowych
 na pojedynczym układzie.
\end_layout

\begin_layout Section
Infineon Technologies
\end_layout

\begin_layout Standard
Firma Infineon Technologies z siedzibą w Niemczech to producent układów
 półprzewodnikowych znany przede wszystkim z układów pamięci DRAM.
 Jest dynamicznie rozwijającą się firmą powstałą z wydzielenia działu półprzewod
ników z firmy Siemens w 1994 roku.
\end_layout

\begin_layout Standard
Wśród produktów Infineon znajdują się mikroprocesory trójrdzeniowe w architektur
ze TriCore, z których każdy pełni inną specjalizowana funkcję mikrokontrolera,
 DSP i podsystemu ładująco-zapisującego z uproszczonym zestawem instrukcji
 oraz procesory radiowe dla telefonii komórkowej (ang.
 
\shape italic
\lang british
baseband processor
\shape default
\lang polish
).
 W katalogu oferowanych mikroprocesorów znajduje się poza tym kilka rodzin
 układów mikrokontrolerów:
\end_layout

\begin_layout Itemize
8-bitowe: XC8000 i C500 w architekturze Intel 8051,
\end_layout

\begin_layout Itemize
16-bitowe: XC166, C166 i XE166,
\end_layout

\begin_layout Itemize
32-bitowe: AUDO Future, Audo NextGeneration, TC116X, TC1130
\end_layout

\begin_layout Itemize
linię XC2000, która ma mieszaną architekturę 16- i 32-bitową.
\end_layout

\begin_layout Standard
Praktycznie wszystkie układy mają specjalizowane zastosowania i poza architektur
ą TriCore są przede wszystkim skierowane do przemysłu motoryzacyjnego.
 W przypadku układów 32-bitowych Infineon przewiduje znacznie szersze zastosowan
ia.
\end_layout

\begin_layout Section
Texas Instruments
\end_layout

\begin_layout Standard
Firma Texas Instruments jest bardzo znanym producentem elektroniki dla zastosowa
ń wojskowych i słynie z kalkulatorów naukowych, których rola spadła w dzisiejszy
ch czasach, gdy dostęp do notebooków i palmtopów jest na porządku dziennym.
 Najważniejszą dziedziną działania tej firmy jest aktualnie rozwijanie nowatorsk
ich technologii, takich jak DLP oraz projektowanie i produkcja szerokiej
 gamy układów scalonych dla różnych zastosowań w elektronice.
 Klientami Texas Instruments są firmy działające w każdej istniejącej branży
 przemysłu.
\end_layout

\begin_layout Standard
Mikroprocesory tej firmy mają ogromny udział w rynku telefonii komórkowej.
 Wydajność i możliwości układów tej firmy przyczyniła się do znacznego postępu
 w dziedzinie telefonii 3G, wkrótce prawdopodobnie 4G.
 Wśród oferowanych przez Texas Instruments układów są również 32 bitowe
 mikrokontrolery, w tym również układy o cech DSP, lub z rdzeniami DSP zintegrow
ane (patrz: OMAP).
\end_layout

\begin_layout Subsection
MSP430
\end_layout

\begin_layout Standard
Układu serii MSP430 to nastawione na oszczędność energii 16 bitowe układy
 RISC, które cechują się małymi rozmiarami i bardzo niską ceną.
 Oferowane są w szerokiej gamie wersji, w czterech głównych gałęziach, które
 rozróżnia obsługa wyświetlacza LCD lub jej brak, oraz maksymalna wydajność
 oraz napięcia zasilania.
\end_layout

\begin_layout Standard
Przykładowo układ mikrokontrolera MSP430FG4618 wyposażony w 116
\begin_inset space ~
\end_inset

kB pamięci Flash, 8
\begin_inset space ~
\end_inset

kB RAM, zasilany napięciem 2,2
\begin_inset space ~
\end_inset

V pobiera tylko 400
\begin_inset space ~
\end_inset


\begin_inset Formula $\mu$
\end_inset

A w trakcie aktywności przy 1
\begin_inset space ~
\end_inset

MHz taktowania, 1,3
\begin_inset space ~
\end_inset


\begin_inset Formula $\mu$
\end_inset

A w trakcie spoczynku i 0,22
\begin_inset space ~
\end_inset


\begin_inset Formula $\mu$
\end_inset

A w trybie podtrzymywania pamięci.
 Układ ten został przewidziany do przenośnych urządzeń medycznych.
\end_layout

\begin_layout Subsection
C2000
\end_layout

\begin_layout Standard
Układy rodziny TMS320C2000 są określane przez producenta jako cyfrowe kontrolery
 sygnałowe DSC (ang.
 
\shape italic
\lang british
Digital Signal Controller
\shape default
\lang polish
).
 Jest to hybryda cech mikrokontrolera RISC z architekturą DSP, która przeznaczon
a na jest do szybkiej analizy sygnałów w urządzeniach pomiarowych i pomiarowo-st
erujących.
 Wszystkie układy z tej rodziny posiadają wbudowane kanały PWM, które doskonale
 nadają się do sterowania urządzeń elektromechanicznych.
 Dodatkowo dostępne są wersje wspierające interfejsy CAN, SCI, SPI, I
\begin_inset Formula $^{\text{2}}$
\end_inset

C.
\end_layout

\begin_layout Standard
Istotną cechą dostępną w tej rodzinie jest gałąź układów oznaczana symbolem
 TMS320F283xx, która posiada sprzętową jednostkę do operacji zmiennoprzecinkowyc
h.
 Wydajność maksymalna osiągana w tych układach dochodzi do 300
\begin_inset space ~
\end_inset

MFLOPS przy 150 MHz zegarze taktującym rdzeń mikrokontrolera.
\end_layout

\begin_layout Standard
Dodatkową cechą istotną z punktu widzenia konstruktorów i programistów systemu
 na bazie tych mikrokontrolerów, jest sprzętowe wparcie dla JTAG (patrz
 rozdział 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Interfejs-JTAG"

\end_inset

) pracującego z pełną prędkością układu.
 Zastosowanie JTAG do uruchamiania systemu wymaga zastosowania odpowiedniego
 emulatora, które znajdują się w bogatej ofercie kilku firm współpracujących.
 Oferta układów uruchomieniowych dla tej serii mikrokontrolerów jest bogata,
 jednakże produkty Texas Instruments są drogie.
 Sztandarowe środowisko programistyczne Code Composer Studio również należy
 do drogich narzędzi, choć ewaluacyjne wersje są dostępne za darmo nawet
 na 120 dni.
\end_layout

\begin_layout Subsection
TMS470
\end_layout

\begin_layout Standard
Cała gama układów z serii TMS470 to 32-bitowe mikrokontrolery w architekturze
 ARM
\begin_inset space ~
\end_inset

7 omówionej w sekcji 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:ARM-7"

\end_inset

.
 Lista wersji obejmuje 8 wariantów, różniących się prędkością taktowania,
 ilością pamięci Flash i RAM oraz interfejsami.
 Znajdują one szerokie zastosowanie w motoryzacji i przemyśle.
\end_layout

\begin_layout Subsection
TMS320 i OMAP
\end_layout

\begin_layout Standard
Firma Texas Instruments słynie na cały elektroniczny świat z projektowania
 i produkcji jednych z najbardziej uznanych procesorów sygnałowych.
 Są stosowane przez prawie wszystkich światowych producentów urządzeń cyfrowych,
 w których działaniu znajduje się przetwarzanie sygnałów -- zaczynając od
 producentów sprzętu audio-video, idąc przez radiokomunikację, na specjalistyczn
ym sprzęcie pomiarowym kończąc.
 W momencie pisania tego tekstu dostępne są już wielordzeniowe układy DSP.
\end_layout

\begin_layout Standard
W dziale DSP wyróżonione są następujące główne gałęzie:
\end_layout

\begin_layout Description
DaVinci to technologia dla procesorów sygnałowych specjalizowanych do bardzo
 wydajnego przetwarzania sygnałów video, jest odpowiedzią Texas Instruments
 na rosnące w ostatnim czasie zapotrzebowanie na przetwarzanie obrazów video
 wysokiej jakości i rozdzielczości; niektóre z wersji posiadają rdzeń ARM
\begin_inset space ~
\end_inset

9 (patrz: sekcja 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:ARM-9"

\end_inset

).
\end_layout

\begin_layout Description
OMAP to rodzina procesorów o rdzeniach łączonych z ARM
\begin_inset space ~
\end_inset

9 (patrz: sekcja 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:ARM-9"

\end_inset

) lub ARM Cortex-A8; stosowana dziś najczęściej w multimedialnych telefonach
 komórkowych z racji bogactwa szybkich interfejsów do kamer, wyświetlaczy
 i wielu innych; zoptymalizowana do pracy pod kontrolą systemu Linux lub
 DSP/BIOS
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
DSP/BIOS to nazwa prostego systemu operacyjnego dla DSP oferowanego przez
 Texas Instruments wraz ze środowiskiem inżynierskim CodeComposer.
 Więcej:
\begin_inset CommandInset href
LatexCommand href
name "http://focus.ti.com/docs/toolsw/folders/print/dspbios.html"
target "http://focus.ti.com/docs/toolsw/folders/print/dspbios.html"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Description
C5000 to seria układów o wyjątkowo niskim zużyciu energii i przystosowana
 do optymalizacji zasilania peryferiów, dzięki czemu doskonale nadają się
 do pracy w systemach zasilanych bateriami w branży telekomunikacji i bezpieczeń
stwa.
 
\end_layout

\begin_layout Description
C6000 dzieli się na układy o arytmetyce zmiennopozycyjnej 32- i 64-bitowej
 oraz układy o arytmetyce stałopozycyjnej, w tym taktowane ponad 1 GHz;
 oferowane w konstrukcjach wielordzeniowych i wyposażone wysokowydajne specjaliz
owane interfejsy komunikacyjne, przystosowane do pracy w architekturach
 z pamięciami współdzielonymi, stanowią źródło ogromnej mocy obliczeniowej,
 dzięki której możliwe jest już dziś budowanie wydajnych przyszłościowych
 systemów telekomunikacji i multimediów, takich jak sieci komórkowe piątej
 generacji lub naziemna telewizja cyfrowa wysokiej rozdzielczości.
\end_layout

\begin_layout Standard
Procesory sygnałowe nie będą szczegółowo omawiane, gdyż spektrum możliwości
 zasługuje na objęcie tej działki osobnymi opracowaniami poświęconymi wybranym
 specjalizacjom tych układów.
\end_layout

\begin_layout Section
Microchip Technology
\end_layout

\begin_layout Standard
Firma Microchip Technology z siedzibą w USA to producent bardzo znanych
 układów PIC, które są 8 lub 16-bitowymi mikrokontrolerami w Polsce często
 stosowanymi do celów edukacyjnych.
 Cechą szczególną układów PIC jest ich prostota, co w sytuacjach budowy
 bardzo prostych urządzeń kontrolnych ma niebagatelne znaczenie.
\end_layout

\begin_layout Standard
Od 5 listopada 2007 roku w ofercie Microchip Technology znajdują się układy
 z rodziny PIC32, które rozpoczynają nową linię produktów tej firmy.
\end_layout

\begin_layout Subsection
PIC32
\end_layout

\begin_layout Standard
Od 5 listopada 2007 roku w ofercie Microchip Technology znajdują się układy
 z rodziny PIC32, które rozpoczynają nową linię produktów tej firmy.
 Układy tego typu pracują z częstotliwością 20 lub 72 MHz i mogą posiadać
 do 512 kB pamięci Flash oraz 32 kB pamięci RAM oraz wyposażone są w kontroler
 DMA.
\end_layout

\begin_layout Standard
Jest to całkowicie nowa nie poznana dobrze linia układów mikrokontrolerów,
 dlatego też nie zostanie opisana zbyt dokładnie.
\end_layout

\begin_layout Section
NXP Semiconductors
\end_layout

\begin_layout Standard
Firma NXP Semiconductors z siedzibą w Holandii jest kontynuatorem dokonań
 firmy Philips w zakresie scalonych układów półprzewodnikowych.
 Wśród nich znajdują się układy mikrokontrolerów z rodziny 80C51 oraz układy
 oparte o rdzenie ARM7 i ARM9 opisane w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ARM"

\end_inset

.
\end_layout

\begin_layout Section
STMicroelectronics
\end_layout

\begin_layout Standard
Firma STMicroelectronics z siedzibą w Szwajcarii jest twórcą i producentem
 znanych układów 8-bitowych serii ST6 i ST7.
 Ma w swojej ofercie również 16-bitowe układy serii ST10.
 Rodzina 32-bitowych układów STM32, STR7 i STR9 produkowanych przez tą firmę,
 to konstrukcje bazujące na rdzeniach z firmy ARM (szerzej rozdział 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ARM"

\end_inset

).
\end_layout

\begin_layout Section
Zilog
\end_layout

\begin_layout Standard
Firma Zilog z siedzibą w Kaliforni istnieje od 1974 roku do dnia dziesiejszego,
 choć jej biznesowe losy przechodziły pewne perturbacje.
 Założona została przez Federico Fagginiego, która pracował wcześniej nad
 projektem procesora 8080 w firmie Intel.
 W roku 1976 wypuściła jeden z najsłynniejszych procesorów oznaczonych Z80,
 który był znacznie zmodyfikowaną wersją 8080.
 Do historii przeszedł dzięki słynnym komputerom osobistym ZX Spectrum firmy
 Sinclair Research, za konstrukcję którego Clive Marles Sinclair otrzymał
 w roku 1983 tytuł szlachecki.
\end_layout

\begin_layout Standard
Istotną ciekawostką jest fakt, że procesor Z80 jest produkowany i stosowany
 w urządzeniach elektronicznych do dnia dziesiejszego.
 Zilog produkuje wiele wcieleń tego procesora, w tym Z8 i Z180.
 Mikrokontroler eZ80 Acclaim to układ na bazie rdzenia Z80, ale zaprojektowany
 do pracy w urządzeniach.
 W ofercie firmy znajdują się również układy ZNEO o architekturze 16-bitowej,
 oraz układy Zatara i Encore!
\begin_inset space ~
\end_inset

32 o architekturze 32-bitowej na bazie rdzenia ARM9 (patrz 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:ARM-9"

\end_inset

).
\end_layout

\begin_layout Chapter
Języki programowania
\end_layout

\begin_layout Section
C
\end_layout

\begin_layout Standard
Autorem języka jest Dennis Ritchie, który zapisał się w historii informatyki
 swoim udziałem w tworzeniu systemu operacyjnego Unix.
 Razem z Brianem Kerninghanem rozwijali język C, by w 1978 roku opublikować
 dokumentację języka.
 Do dziś język C jest wykorzystywany w poważnych projektach informatycznych
 i jest jedynym językiem wysokiego poziomu uznawanym za dostatecznie bliski
 niskiego poziomu, by tworzyć w nim systemy operacyjne i sterowniki urządzeń.
 Stosowanie go w projektach komercyjnych budzi dziś jednak spore kontrowersje,
 gdyż kod w C jest trudny i kosztowny w utrzymywaniu.
\end_layout

\begin_layout Standard
W roku 1989 pojawiła się pierwsza norma dla języka C w postaci standardu
 ANSI
\begin_inset space ~
\end_inset

X3.159-1989.
 W 1990 roku norma amerykańska została zaadoptowana standardu w formie normy
 ISO
\begin_inset space ~
\end_inset

9899:1990.
 Standard ten był wielokrotnie modyfikowany by doczekać się wersji ISO
\begin_inset space ~
\end_inset

9899:1999, potocznie określaną jako C99.
\end_layout

\begin_layout Standard
Zaletą języka C jest jego prostota i wydajny kod wynikowy.
 Do wad należy zaliczyć istnienie niezdefiniowanych zachowań, nie weryfikowanych
 przez kompilator, które często służą do wykonywania bardzo skomplikowanych
 zabiegów przez biegłych i doświadczonych programistów.
 Wśród innych wad jest stosowanie niezabezpieczonych wskaźników, bardzo
 przydatnych w programowaniu niskopoziomowym, lecz będących przyczyną bardzo
 wielu poważnych błędów w programach pisanych w języku C.
 Kolejny kłopot sprawiają statyczne tablice, których zasięg nie podlega
 sprawdzaniu, w przeciwieństwie do języka Pascal.
 Tablice są częstą przyczyną luk bezpieczeństwa w programach pisanych w
 języku C.
\end_layout

\begin_layout Standard
Język C jest dobrym narzędziem dla doświadczonego programisty potrzebującego
 napisać kod działający na niskim poziomie, ściśle związany z współpracą
 z programowanym urządzeniem.
 Dodatkowo powinien być stosowany w programowaniu obliczeń wysokiej wydajności,
 lecz pod warunkiem zastosowania bardzo dużego rygoru kontroli kodu i trzymania
 się czytelnego standardu kodowania.
\end_layout

\begin_layout Section
C++
\end_layout

\begin_layout Standard
Język C++ powstał jako obiektowe rozszerzenie języka C, a jego autor --
 Duńczyk Bjarne Stroustrup -- bazował na takich językach jak Simula, Algol,
 Ada, ML
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Z funkcyjnego języka ML wykształcił się również język Ocaml, mający dziś
 wielu zwolenników.
\end_layout

\end_inset

 i Clu.
 Stopniowo pojawiało się w nim jednak wiele innych ulepszeń, z których część
 została później przeniesiona do C99.
 Język C++ jest bardzo często stosowany w programowaniu komercyjnym, gdyż
 stosowany zgodnie ze sztuką kompozycji obiektowej, nadal pozwala na wygenerowan
ie optymalnego i szybkiego kodu maszynowego.
\end_layout

\begin_layout Standard
Wadą języka C++ jest specyficzne pomieszanie go z elementami charakterystycznymi
 dla C, co dla początkującego programisty może być trudne do zrozumienia,
 ale prowadzi również do tworzenia kodu bardzo niskiej jakości i trudnego
 w zarządzaniu.
 Natomiast najczęściej popełnianym błędem przez doświadczonych programistów
 w C, którzy przesiadają się na C++ jest pisanie kodu jak w języku C, tylko
 otoczonego klasami.
 Tak napisany kod jest bardzo podatny na wprowadzanie nowych błędów przy
 poprawianiu, a do tego nie utrzymuje zgodności z modelem obiektowym znanym
 np.
 z UML.
\end_layout

\begin_layout Standard
Do przydatnych cech języka poza obiektowością, należy zaliczyć szablony,
 które pozwalają na programowanie generyczne, to znaczy bez znajomości typów
 danych na których operują stworzone klasy i metody.
 Z szablonami wiąże się też biblioteka STL, dziś nierozerwalnie złączona
 z każdym kompilatorem C++, choć istniejące obecnie stosowane biblioteki
 STL to kolejne wersje zaproponowanej przez Silicon Graphics pierwszej komercyjn
ie stosowanej implementacji oraz biblioteka STLport
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Dostępna jako kod otwarty pod adresem http://www.stlport.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Java
\end_layout

\begin_layout Standard
Język Java od samego początku tworzony był do celów komercyjnych przez profesjon
alny zespół pod kierunkiem Jamesa Goslinga z firmy Sun Microsystems
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Do dziś strona numer jeden języka Java to http://java.sun.com
\end_layout

\end_inset

.
 Język ten bazuje na koncepcjach obiektowością z języka Smalltalk, lecz
 składnia bazuje na języku C++, przy czym w Java nie ma plików nagłówkowych.
 Dodatkowo z języka Smalltalk zaczerpnął również idee maszyny wirtualnej
 i odśmiecacza (ang.
 
\shape italic
\lang british
garbage collector
\shape default
\lang polish
).
 W przeciwieństwie do Smalltalk w języku Java istnieje silne typowanie,
 choć typowanie może się w pewien sposób odbywać dynamicznie (możliwy jest
 dzięki temu mechanizm refleksji).
 Od C++ odróżnia Javę w szczególności brak wielokrotnego dziedziczenia oraz
 możliwość tworzenia interfejsów, które jednak w przeciwieństwie do klas
 abstrakcyjnych C++ nie mogą implementować żadnej funkcjonalności.
\end_layout

\begin_layout Standard
Cechą wyróżniającą język Java i wszystkie narzędzia współpracujące jest
 niezależność od sprzętu, dzięki zastosowaniu maszyn wirtualnych, które
 mogą być realizowane dla wielu platform sprzętowych, w tym tak popularnych
 dziś telefonów komórkowych.
 Gwałtowny rozwój Javy miał miejsce w okresie szczególnym dla rozwoju urządzeń
 osobistych.
 Dzięki temu wizja firmy Sun została częściowo zrealizowana -- gdy po raz
 pierwszy zademonstrowano tą technologię, zapowiadano jej obecność w każdym
 urządzeniu, nawet w pralce.
\end_layout

\begin_layout Standard
Maszyny wirtualne Java są tworzone dziś nie tylko przez firmę Sun, ale również
 innych producentów, w tym IBM, którego wersje dla systemów AIX i Linux
 są ogólnie dostępne.
 Firma Microsoft zarzuciła rozwój swojej wersji maszyny wirtualnej po przegranym
 procesie o prawa do patentów z Sun Microsystems.
 Istnieje wiele implementacji stworzonych jako wolny kod, w tym:
\end_layout

\begin_layout Itemize
JamVM
\end_layout

\begin_layout Itemize
Kaffe
\end_layout

\begin_layout Standard
Od 13 Listopada 2006 technologia Java z firmy Sun Microsystems została przekazan
a na rzecz społeczności na licencji GNU GPL.
 Aktualnie technologia firmy Sun jest rozwijana równolegle z udziałem wkładu
 programistów z całego świata, przy czym firma nadal zarządza całym projektem
 ze swoich stron internetowych.
\end_layout

\begin_layout Standard
Ciekawym aspektem języka Java są wielokrotnie podejmowane próby stworzenia
 kompilatorów do natywnego kodu maszynowego docelowej platformy, co stoi
 w sprzeczności z założeniem o pełnej przenoszalności kodu, jednak ma znacząco
 pozytywny wpływ na wydajność tak skompilowanych programów.
 Pośród takich kompilatorów znajduje się GCJ, który może dokonać translacji
 do bajt-kodu dla maszyny wirtualnej, jak również kompilacji bajt-kodu do
 natywnego kodu maszynowego.
 Umożliwia też mieszanie kodu w bajt-kodzie i binarnego kodu natywnego.
 Aktualnie GCJ wspiera standard Java 1.4, z pewnymi rozszerzeniami z Java
 1.5.
\end_layout

\begin_layout Standard
W związku z gwałtownym rozwojem języka Java na platformy wbudowane, podjęto
 próby skonstruowania procesora, który potrafiłby wykonywać bajt-kod języka
 Java.
 Sum Microsystems oferuje wersję źródłową rdzenia dla bajt-kodu Java do
 mikroprocesorów.
 Firma Xilinx oferuje LAVAcore, które jest kompletną implementacją mikroprocesor
a bajt-kodu Java dla układów FPGA typu Virtex i Virtex-II.
 W rozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Jazelle"

\end_inset

 wspomniana została technologia Jazelle opracowana dla rdzeni mikroprocesorów
 ARM, która jest technologią przyspieszania wykonania bajt-kodu Java na
 tych mikroprocesorach.
\end_layout

\begin_layout Standard
Oprócz rozwiązań komercyjnych istnieje kilka udanych konstrukcji stworzonych
 w ramach prac badawczych na uniwersytetach.
 Jedną z nich jest JOP
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Strona projektu http://www.jopdesign.com
\end_layout

\end_inset

 stworzony w ramach pracy doktorskiej Martina Schoeberla na Wiedeńskim Uniwersyt
ecie Technicznym, którego źródła do celów edukacyjnych są dostępne nieodpłatnie.
\end_layout

\begin_layout Section
Python
\end_layout

\begin_layout Standard
Język Python narodził się jako efekt prac Guido van Rossuma nad następcą
 języka ABC w Stichting Mathematisch Centrum w Holandii.
 Od roku 1995 prace były kontynuowane w Corporation for National Research
 Initiatives w Virginii, USA.
 W maju roku 2000 van Rossum przenosi główny zespół rozwijający Python do
 firmy BeOpen.com i formuje BeOpen PythonLabs.
 W październiku tego samego roku, zespół PythonLabs przenosi się do Digital
 Creations, później przekształcone w Zope Corporation.
 W roku 2001 powołana zostaje Python Software Foundation, organizacja niedochodo
wa utworzona w celu utrzymywania własności intelektualnej związanej z językiem
 Python i technologiami z nim związanymi.
 Zope Corporation jest członkiem sponsorującym PSF.
 Dzięki takiej formie działania, Python zachowuje swoją otwartość nie pozostawia
jąc wątpliwości prawnych co do własności intelektualnych, a fundusze zebrane
 przez PSF pozwalają na obronę przed pozwami o naruszanie patentów lub prawa
 autorskiego.
\end_layout

\begin_layout Standard
Jedną ze szczególnych cech wyróżniających język Python na tle innych popularnych
 języków programowania używanych dziś powszechnie, jest stosowanie formatowania
 kodu jako składni języka.
 Oznacza to, że bloki w kodzie są tworzone przez wcięcia, a nie przez oznaczanie
 początku i końca za pomocą nawiasów (jak w C) lub słów kluczowych (jak
 w Pascalu).
 Narzucanie pewnego stylu kodowania ma swoich przeciwników i zwolenników,
 jednakże ma to wpływ na szybsze pisanie kodu przez programistę.
 Poprawia też czytelność kodu, ułatwiając rozwijanie kodu w zespołach programist
ycznych.
\end_layout

\begin_layout Standard
Do zalet Pythona należy zaliczyć bogactwo operatorów działających na zbudowanych
 typach danych, takich jak lista, krotka, słownik.
 Prawdziwa siła języka Python tkwi właśnie w umiejętnym i wydajnym stosowaniu
 tych możliwości.
 W efekcie w krótkim programie, można zrealizować dużą funkcjonalność.
 Przeładowywanie metod pozwala na tworzenie klas, których zachowanie pokrywa
 się z zachowaniem niektórych typów wbudowanych.
 Możliwe jest też konstruowanie modułów binarnych pisanych w językach niższego
 poziomu, jak C i C++.
 Równocześnie interpreter języka Python może być wbudowywany w inne aplikacje,
 jako ich język skryptowy (np.
 w programie Blender).
 Dla języka Java istnieje pełna implementacja Pythona o nazwie Jython, która
 nie posiada jedynie modułów specyficznych systemowo dostępnych w oryginalnym
 Pythonie.
 Jython działa całkowicie w formie bajt-kodu Javy -- dotyczy to zarówno
 interpretera poleceń, jak i samego kodu uruchamianego w nim.
 Możliwy jest dostęp do wszystkich API języka Java.
\end_layout

\begin_layout Standard
Język Python jest językiem słabo typowanym, czyli zmienne mogą zmieniać
 swój typ w trakcie wykonywania programu.
 Mechanizm ten może być problematyczny w większych projektach, gdyż API
 tworzonych modułów wymaga dokumentowania typów parametrów, dla zachowania
 przejrzystości.
 Jednak dynamiczne rozpoznawanie typów danych nadaje się do wykorzystania
 w algorytmie, co pozwala w prosty sposób realizować pewne zadania, wymagające
 złożonego kodu w innych językach.
\end_layout

\begin_layout Standard
Dodatkowym atutem tego języka jest mechanizm generatorów, który polega na
 konstruowaniu funkcji zwracającej rezultat swojego wykonania wraz zapamiętaniem
 swojego wewnętrznego stanu i powrocie do punktu ostatniego wyjścia przy
 kolejnym wywołaniu.
 Jest to szczególnie przydatne w tworzeniu metod klas, które stanowią kontenery
 przechowujące elementy, po których potrzebna jest iteracja.
\end_layout

\begin_layout Standard
Aby poprawić wydajność kluczowych elementów tworzonej aplikacji, Python
 umożliwia wspomniane wcześniej wykorzystanie modułów napisanych w językach
 kompilowanych do natywnego kodu procesora.
 Jest to możliwe dzięki dobrze udokumentowanemu interfejsowi oraz kilku
 projektom ułatwiającym realizację tego zadania.
 Jednym z nich jest Cython, który jest językiem do pisania modułów rozszerzający
ch dla Python z równą łatwością, co kodu w samym języku Python.
 Jest on następnie przegenerowywany na kod w języku C, który może zostać
 skompilowany wybranym kompilatorem języka C.
 Cython jest bardzo bliski oryginalnemu językowi, ma jednak kilka ograniczeń,
 jak również pozwala dodatkowo wywoływać funkcje języka C oraz deklarować
 typy zmiennych i atrybutów klas.
\end_layout

\begin_layout Standard
Biblioteki języka Python, zarówno te dostarczane standardowo, jak również
 dostępne w ramach odrębnych projektów, czynią z Python'a bardzo potężne
 narzędzie inżynierskie.
 Popularność Pythona rośnie nie tylko w kręgach wykorzystujących go jako
 język skryptowy, ale również w poważnych komercyjnych zastosowaniach biznesowyc
h i technicznych.
 Jest z sukcesem stosowany w takich organizacjach jak NASA i Industrial
 Light
\begin_inset space ~
\end_inset

&
\begin_inset space ~
\end_inset

Magic.
\end_layout

\begin_layout Standard
\begin_inset Branch ASN.1
status collapsed

\begin_layout Section
ASN.1
\end_layout

\begin_layout Standard
Język ASN.1 (ang.
 
\shape italic
\lang british
Abstract Syntax Notation One
\shape default
\lang polish
) nie jest językiem programowania w rozumieniu algorytmicznym, ale deklaratywnym
 opisem struktur danych.
 Stanowi on abstrakcyjną notację do opisu struktur danych przeznaczonych
 do kodowania i dekodowania danych transmitowanych w sposób spójny w złożonych
 systemach niezależnie od platformy sprzętowej.
 Standard ten został po raz pierwszy opisany w roku 1984 jako część dokumentu
 CCITT (ang.
 
\shape italic
\lang british
Consultative Committee International Telegraphy and Telephony
\shape default
\lang polish
) numer X.409'84, a w roku 1988 wydzielony jako samodzielny standard ITU-T/ISO
 w formie dokumentu ITU-T
\begin_inset space ~
\end_inset

X.208.
 W roku 1994 wydano nowa wersja opisana została w dokumentach ITU-T z serii
 X.680 (X.680-X.683).
 W roku 2002 wycofano dokument ITU-T X.208.
 Standard ASN.1 znajduje zastosowanie w wielu dokumentach ITU-T w tym w serii
 X.400 (poczta), w serii X.500 (usługi katalogowe) oraz w specyfikacji standardu
 SNMP (ang.
 
\shape italic
\lang british
Simple Network Management Protocol
\shape default
\lang polish
) do opisu typów danych dla MIB (ang.
 
\shape italic
\lang british
Management Information Base
\shape default
\lang polish
).
\end_layout

\begin_layout Standard
Kod opisujący struktury danych kompilowany jest do postaci kodu źródłowego
 w języku programowania, najczęściej języka C.
 Dopiero tak wygenerowany moduł staje się częścią kodu programu, który jest
 używany do kodowania danych w sposób niezależny od platformy.
 Przy czym kodowanie odbywa się według reguł kodowania zdefiniowanych niezależni
e od samego języka.
 Aktualnie rozróżnia się następujące typy kodowań w ASN.1:
\end_layout

\begin_layout Description
BER (ang.
 
\shape italic
\lang british
Basic Encoding Rules
\shape default
\lang polish
) to oryginalne reguły zawarte w standardzie ASN.1 do zakodowania abstrakcyjnych
 informacji do konkretnego strumienia danych.
 Reguły te, określane mianem składni transferu w terminologii ASN.1, określa
 dokładną kolejność oktetów użytych do zakodowania strumienia danych.
 Składnia definiuje elementy takie, jak reprezentacja podstawowych typów
 danych, struktura długości informacji oraz znaczenia do definiowania złożonych
 typów na bazie typów prostych.
 Składnia BER wraz z dwoma podzbiorami CER i DER są zdefiniowane w dokumencie
 ITU-T X.690 (
\begin_inset CommandInset citation
LatexCommand cite
key "X690"

\end_inset

).
\end_layout

\begin_deeper
\begin_layout Standard
Ponieważ BER stosuje prostą składnię, łatwą do implementacji, wynikowy strumień
 danych jest skonstruowany mało efektywnie.
 Powszechnie uważa się, że inne reguły kodowania są bardziej praktyczne
 w rzeczywistych realizacjach systemów korzystających z ASN.1.
 Nie przeszkadza to jednak w stosowaniu BER w wielu rozwiązaniach rzeczywistych
 (SNMP, LDAP, sygnalizacja ISDN).
\end_layout

\end_deeper
\begin_layout Description
CER (ang.
 
\shape italic
\lang british
Canonical Encoding Rules
\shape default
\lang polish
) jest podzbiorem reguł BER, wybierającym z całego zestawu możliwych metod
 zakodowania danych tylko te, które nie określają skończonych długości elementów
 strumienia danych.
 Oznacza to, że zawsze stosowany jest znacznik końca elementu struktury
 abstrakcyjnej, zamiast znacznika określającego długość.
 Dzięki czemu do zakodowania długich informacji potrzeba mnie metadanych
 w strumieniu.
\end_layout

\begin_layout Description
DER (ang.
 
\shape italic
\lang british
Distinguished Encoding Rules
\shape default
\lang polish
) jest podzbiorem reguł BER, ograniczającym sposób kodowania danych do jednoznac
znej metody polegającej na podawania znacznika długości do każdego elementu
 strumienia danych.
 DER jest stosowane w kryptografii cyfrowej do zapewnienia, że struktura
 danych poddawana podpisowi cyfrowemu, jest budowana z unikalnego ciągu
 serializującego zadane informacje.
 DER uważany jest za drugą formę kanoniczną BER.
\end_layout

\begin_layout Description
XER (ang.
 
\shape italic
\lang british
XML Encoding Rules
\shape default
\lang polish
) jest zbiorem reguł dodanych do ASN.1 pozwalającym na zakodowanie danych
 w strumieniu danych będących dokumentem XML.
\end_layout

\begin_layout Description
PER (ang.
 
\shape italic
\lang british
Packed Encoding Rules
\shape default
\lang polish
) to zdefiniowane w 1994 roku reguły składni transferowej dla struktur opisanych
 w ASN.1, które dostarczają dużo bardziej zwartego kodowania niż BER.
 PER próbuje prezentować jednostki danych na minimalnej liczbie bitów.
 Zwartość wymaga jednak, by dekoder znał całość abstrakcyjnej składni struktur
 danych, aby móc je zdekodować.
 W większości przypadków, nie stanowi to problemu, bo aplikacja zna struktury
 danych, którymi się posługuje.
\end_layout

\begin_deeper
\begin_layout Standard
Istnieją dwa warianty reguł spakowanych: niewyrównane i wyrównane.
 W pierwszym wypadku, bity upakowane są bez zważania dla granice oktetów
 (bajtów).
 W przypadku wyrównanym, określone typy struktury danych są wyrównywane
 do granic oktetów, co oznacza marnotrawstwo części bitów.
 Niewyrównane kodowanie zużywa mniej bitów, kosztem jednak czasu przetwarzania
 strumienia danych.
 Typowe procesory są słabo przystosowane do danych niewyrównanych do bajtów,
 a współcześnie nawet wymagają posługiwania się całymi słowami, by nie tracić
 na wydajności.
\end_layout

\begin_layout Standard
Standard kodowania PER jest aktualnie opisany w dokumentach ITU-T X.691 (
\begin_inset CommandInset citation
LatexCommand cite
key "X691"

\end_inset

) oraz ISO 8825-2.
\end_layout

\end_deeper
\begin_layout Description
GSER (ang.
 
\shape italic
\lang british
Generic String Encoding Rules
\shape default
\lang polish
) jest zestawem reguł kodowania do tworzenia wymownej, czytelnej dla człowieka
 formy tekstowej składni transferowej dla struktur danych opisanych w ASN.1.
 
\end_layout

\begin_deeper
\begin_layout Standard
Celem GSER jest reprezentacja zakodowanych danych użytkownikowi lub przyjmowanie
 od niego danych w najprostszej możliwej formie.
 Zestaw ten został oryginalnie opracowany na potrzeby LDAP (ang.
 
\shape italic
\lang british
Lightweight Directory Access Protocol
\shape default
\lang polish
)
\emph on
 
\emph default
i jest rzadko stosowany poza nim.
 Stosowanie GSER współcześnie jest zniechęcające, gdyż nie każdy sposób
 kodowania znaków w ciągach wspierany przez ASN.1 może być w nim reprodukowany.
\end_layout

\begin_layout Standard
Specyfikacja reguł kodowania GSER znajduje się w RFC 3641 i w przeciwieństwie
 do pozostałych reguł nie stanowi standardu ITU-T ani ISO.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
dupa jaś karuzela coś jeszcze trzeba tu wpisać...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Lua
status open

\begin_layout Section
Lua
\end_layout

\begin_layout Standard
Język skryptowy Lua (port.
 
\shape italic
\lang brazilian
Księżyc
\shape default
\lang polish
) narodził się w Brazylii, w roku 1993 na Uniwersytecie Papieskim w Rio
 de Janeiro w Brazylii.
 Był rezultatem embarga technologicznego obowiązującego w Brazylii do 1992
 roku, podtrzymywanego przez nacjonalistów uważających, że Brazylia ma dość
 potencjału do rozwoju własnego sprzętu komputerowego i oprogramowania.
 Troje członków grupy komputerowych technologii graficznych Uniwersytetu
 Papieskiego: Roberto Ierusalimschy, Luiz Henrique de Figueiredo oraz Waldemar
 Celes, stworzyło ten język dla aplikacji inżynieryjnych na półpaństwowej
 firmy Petrobras.
 Autorom języka szczególnie zależało na prostocie, gdyż w założeniach przewidywa
ne było posługiwanie się tym językiem przez inżynierów, nie będących programista
mi.
\end_layout

\begin_layout Standard
Lua jest językiem wielu paradygmatów, elementy składni pochodzą z takich
 języków jak Modula, CLU, C++, Snobol, AWK, jednakże zestaw głównych funkcjonaln
ości jest ograniczony.
 Lua nie ma wbudowanych wielu mechanizmów, które mogą być prosto zaimplementowan
e, pozwalając na prowadzenie paradygmatu programowania funkcyjnego lub obiektowe
go.
 Lua jest językiem dynamicznie typowanym, który posiada tylko kilka typów
 podstawowych: logiczny, liczbowy (w przeciwieństwie od innych języków domyślnie
 zmiennopozycyjny), ciąg znaków.
 Wszystkie złożone typy danych, takie jak wektory, zbiory, listy, rekordy,
 mogą być zrealizowane za pomocą jedynej struktury danych zwanej tablicą,
 która w rzeczywistości jest tablicą asocjacyjną.
\end_layout

\begin_layout Standard
W rezultacie wszystkich decyzji projektowych, interpreter języka Lua jest
 bardzo niewielki objętościowo.
 Skompilowany zajmuje około 150
\begin_inset space ~
\end_inset

kB i może być łatwo zaadoptowany do wielu aplikacji.
 Kod źródłowy jest kompilowany do bajt-kodu, który następnie wykonywany
 jest w maszynie wirtualnej.
 W tym wypadku jednak, podobnie jak ma to miejsce w Python, kod binarny
 Lua jest nieprzenośny ze względu na optymalizację dla architektury docelowego
 procesora.
\end_layout

\begin_layout Standard
Interfejs programistyczny do języka C jest bardzo prosty i pozwala na interakcję
 z interpreterem na poziomie stosu wywołań.
 Dostępna jest biblioteka, która pozwala na wykonywanie operacji współdziałania
 z interpreterem Lua na trochę wyższym poziomie.
\end_layout

\begin_layout Subsection
Embedded Lua -- eLua
\end_layout

\begin_layout Standard
Projekt eLua ma na celu wprowadzenie języka Lua do świata programowania
 wbudowanego.
 Główną intencją autorów Bogdana Marinescu i Dado Suttera jest stworzenie
 środowiska programistycznego na samym mikrokontrolerze, bez potrzeby instalacji
 specyficznych narzędzi po stronie PC.
 Ewolucja projektu zmierza w kierunku udostępnienia podstawowego edytora
 skryptów używalnego na różnych urządzenia wejścia/wyjścia, znajdującego
 się w programie mikrokontrolera.
 W momencie pisania tego tekstu, oficjalne wsparcie dostępne jest dla architektu
ry ARM, jednakże planowany jest rozwój innych platform.
\end_layout

\begin_layout Standard
Doświadczenia w uruchamianiu interpretera Lua na mikrokontrolerach będą
 przeniesione do realizacji sterownika robota, gdzie skrypty wykonawcze
 będą ładowane z programu sterującego na komputerze PC.
 Osiągnięta zostanie wysoka elastyczność w funkcjonalności, która będzie
 mogła być rozszerzana na żądanie, bez ponownej kompilacji kodu binarnego
 programu mikrokontrolera.
\end_layout

\begin_layout Standard
Szczegółowy opis projektu dostępny jest pod adresem 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.eluaproject.net/
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Silniki-elektryczne"

\end_inset

Silniki elektryczne
\end_layout

\begin_layout Standard
Cechą charakterystyczną robota jest wytwarzanie pewnych sił i momentów mechanicz
nych w sposób kontrolowany.
 Najpopularniejszą metodą na wytworzenie powyższych jest przekształcanie
 energii elektrycznej na energię mechaniczną poprzez silniki elektryczne.
 W rozdziale tym omówione zostały podstawy budowy komutatorowych silników
 elektrycznych obcowzbudnych prądu stałego, to jest takich jak stosowane
 w omawianej konstrukcji robota.
\end_layout

\begin_layout Standard
Prawidłowe sterowanie cyfrowe silnikiem elektrycznym prądu stałego wymaga
 pewnej podstawowej wiedzy z zakresu budowy silnika, mechaniki jego działania
 oraz zasad przekształcania energii elektrycznej na pole magnetyczne a następnie
 na moment obrotowy.
\end_layout

\begin_layout Standard
Poza omawianym typem silnika elektrycznego istnieje wiele innych typów w
 odmianach różniących się szczegółami konstrukcji i zastosowaniami.
 Nie jest przedmiotem tej pracy omawianie wszystkich typów silników elektrycznyc
h.
 Aby zrozumieć pewne elementy klasyfikujące, omówienie silnika należy rozpocząć
 od wyjaśnienia kilku pojęć:
\end_layout

\begin_layout Description
komutatorowy silnik elektryczny to konstrukcja w której zasilanie twornika
 -- uzwojenia w którym indukuje się siła elektromotoryczna -- odbywa się
 przez element przełączający zasilanie poszczególnych cewek, zwany komutatorem
 (patrz: sekcja 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Komutator"

\end_inset

);
\end_layout

\begin_layout Description
obcowzbudny silnik elektryczny ma stojan z magnesu trwałego (magneśnica)
 lub z elektromagnesu zasilanego z osobnego źródła zasilania niż obwód twornika;
 w omawianym przypadku mamy konstrukcje z magnesem stałym.
\end_layout

\begin_layout Section
Stojan i twornik
\end_layout

\begin_layout Standard
W opisywanym typie silnika elektrycznego stojan jest elementem nieruchomym
 zbudowanym z magnesów trwałych lub ma wbudowane magnesy trwałe, stanowiącymi
 elementy wzbudzające.
 Jest to pole magnetyczne, którego indukcja magnetyczna nie zależy od zasilania
 silnika.
 Dlatego w tym przypadku mówimy o silniku obcowzbudnym.
\end_layout

\begin_layout Standard
Twornik to uzwojenie wytwarzające pole elektromagnetyczne, które oddziałując
 z wzbudzającym polem magnetycznym wytarza ruch obrotowy wirnika.
 W omawianym przypadku twornik znajduje się na wirniku i pojedyncze uzwojenia
 są zasilane poprzez komutator.
\end_layout

\begin_layout Standard
Dla istotnej części, silnik prądu stałego może być przybliżony jako element
 indukcyjny i źródło napięcia.
 W wielu wypadkach istotne jest też uwzględnienie rezystancji w modelu silnika:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/motor_model.svg
	width 90col%
	BoundingBox 0bp 0bp 721bp 146bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Uproszczony model elektryczny silnika prądu stałego
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cewka reprezentuje zwoje twornika, rezystor -- straty eklektyczne.
 Źródło napięcia reprezentuje 
\begin_inset Quotes pld
\end_inset

napięcie generatora
\begin_inset Quotes prd
\end_inset

 i jest proporcjonalne do prędkości obrotowej silnika i jest oznaczone jako
 
\begin_inset Formula $\textrm{U}{}_{\text{g}}$
\end_inset

.
 Prąd płynący przez silnik jest proporcjonalny do momentu obrotowego.
 
\end_layout

\begin_layout Standard
Są dwie ważne skrajności.
 Jedna.
 gdy silnik pracuje bez obciążenia.
 W tym momencie moment obrotowy silnika jest użyty do kompensacji strat.
 Jeżeli zlekceważymy to na chwilę, wtedy zobaczymy, że prąd wynosi 0 (nie
 jest potrzebny moment) i napięcia na stykach wynosi 
\begin_inset Formula $\textrm{U}{}_{\text{g}}$
\end_inset

.
 Po uwzględnieniu również strat, prąd nadal pozostanie niski, a napięcie
 na stykach nadal bliskie 
\begin_inset Formula $\textrm{U}{}_{\text{g}}$
\end_inset

.
\end_layout

\begin_layout Standard
Druga skrajność ma miejsce, kiedy silnik jest zablokowany.
 Wtedy nie ma obrotów, więc 
\begin_inset Formula $\textrm{U}{}_{\text{g}}$
\end_inset

 wynosi 0.
 Motor pełni rolę cewki.
 Prąd płynący przez silni wytworzy moment, jednak napięcie na stykach będzie
 0 (lub bliskie 0 uwzględniając straty).
\end_layout

\begin_layout Standard
Możemy zignorować straty w wielu przypadkach w trakcie omawiania, lub założyć,
 że są stałe.
 W wielu wypadkach straty silnika są zależne od prędkości.
 Przyjmujemy 
\begin_inset Formula $\textrm{L}{}_{\text{m}}$
\end_inset

, 
\begin_inset Formula $\textrm{R}{}_{\text{m}}$
\end_inset

i 
\begin_inset Formula $\textrm{U}{}_{\text{g}}$
\end_inset

 jako stałe przy zadanej prędkości, przynajmniej dla istotnej części.
 W rzeczywiści jednak, na skutek komutacji w silniku i relatywnej pozycji
 przewodzących zwojów względem pola magnetycznego stojanów, wszystkie te
 wartości są funkcją położenia twornika.
 To jest aspekt istotny dla omówienia zwrotnych zakłóceń elektromagnetycznych
 i ich pomiaru.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Komutator"

\end_inset

Komutator
\end_layout

\begin_layout Standard
Komutator w silniku prądu stałego dostarcza energię do wirnika.
 Komutator zbudowany jest z dielektrycznego walca o wysokiej odporności
 temperaturowej, nałożonego na oś wirnika.
 Na powierzchni walca umieszczone są wzdłużnie sekcje połączone z uzwojeniami,
 najczęściej wykonane z miedzi.
 Sekcje izolowane są miedzy sobą szczeliną lub przy pomocy polimerowych
 przekładek.
 Po powierzchni walca ślizgają się grafitowe szczotki dociśnięte przy pomocy
 sprężyn.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/komutator.svg
	lyxscale 50
	width 90col%
	BoundingBox 0bp 180bp 842bp 482bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Diagram-komutatora"

\end_inset

Diagram ilustrujący działanie komutatora silnika prądu stałego
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diagram-komutatora"

\end_inset

 ilustruje zasadę działania komutatora.
 Obracający się walec komutatora powoduje przesuwanie się styków uzwojeń
 pod szczotkami, do których doprowadzone jest napięcie zasilające.
 Kolejne styki są po kolei zasilane w trakcie ruchu obrotowego walca.
 W rzeczywistych silnikach ilość styków na walcu komutatora jest większa
 i może sięgać kilkunastu.
 Działanie komutatora pozwala zasilać tylko te uzwojenia, których pole magnetycz
ne wraz z polem magnetycznym stojana wytwarza chwilowy moment obrotowy.
 W sumie kolejno zasilane uzwojenia wytwarzają moment obrotowy zbliżony
 do jednostajnego.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Mostek H"

\end_inset

Mostek H
\end_layout

\begin_layout Standard
Sterowanie zasilaniem elementów elektroindukcyjnych silników elektrycznych
 prądu stałego odbywa się najczęściej poprzez układ zwany mostkiem H.
 Nazwa jest ściśle związana z wyglądem schematu elektrycznego tego układu.
\end_layout

\begin_layout Subsection
Zasada działania mostka H
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !th
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/mostek_h.svg
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schemat elektryczny mostka H
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elementy przełączające (oznaczenia T1 do T4) są zazwyczaj tranzystorami
 bipolarnymi lub tranzystorami FET, w aplikacjach dla wysokich napięć stosuje
 się - tranzystor bipolarny z izolowaną bramką (ang.
 
\shape italic
\lang british
IGBT, Insulated Gate Bipolar Transistor
\shape default
\lang polish
).
 Istnieją również rozwiązania scalone, jednakże dla rozważań dotyczących
 działania, rozpatrywany będzie układ dyskretny.
 Diody (oznaczenia D1 do D4) są zwane zabezpieczającymi i są to przeważnie
 diody Schottky'ego.
 Chociaż są one wspominane w materiałach dotyczących mostków H, ich rola
 jest z reguły zaniedbywana.
 W rzeczywistości pełnią istotną rolę i muszą być dokładnie omówione.
\end_layout

\begin_layout Standard
Ogólnie, każdy z czterech elementów przełączających może być załączany i
 wyłączany niezależnie, są jednak pewnie oczywiste ograniczenia.
\end_layout

\begin_layout Standard
Podstawowy tryb pracy mostka H jest bardzo prosty: jeżeli T2 i T3 są załączone,
 lewa styk silnika będzie połączony z masą, podczas gdy prawy styk będzie
 połączony z zasilaniem.
 Prąd rozpoczyna przepływ przez silnik, co wywołuje ruch obrotowy wałka
 (umownie) w przód.
 Jeżeli T1 i T4 są załączone, następuje odwrócenie i silnik rozpoczyna ruch
 obrotowy wałka w kierunku wstecznym.
 Jeżeli kontrolowana ma być prędkość silnika, jeden z elementów przełączających
 jest wysterowany przez kontrolowaną szerokość impulsu (ang.
 
\shape italic
\lang british
PWM, pulse width modulation
\shape default
\lang polish
).
 Średnie napięcie widziane przez silnik będzie uzależnione od współczynnika
 pomiędzy czasem załączenia i wyłączenia w sygnale PWM.
\end_layout

\begin_layout Subsection
Diody zabezpieczające
\end_layout

\begin_layout Standard
Diody zabezpieczające (D1 do D4) są często niedocenione i bardzo pobieżnie
 wspomniane w opisach mostków H, jednakże są bardzo istotnym komponentem.
\end_layout

\begin_layout Standard
Podstawowe reguła jest bardzo prosta: kiedy mostek jest włączony, dwa z
 czterech elementów przełączających przenoszą prąd, więc diody nie pełnią
 żadnej roli.
 Jednakże, kiedy mostek jest wyłączony, elementy przełączające przestają
 przewodzić prąd.
 Gdy obciążeniem mostka jest elektryczny silnik prądu stałego, którego charakter
 jest indukcyjny, to w trakcie włączenia powstaje wewnątrz pole elektromagnetycz
ne.
 W czasie braku przewodzenia wszystkich elementów przełączających, to pole
 elektromagnetyczne musi zostać rozładowane, a do czasu gdy to nastąpi,
 prąd płynie przez zwoje.
 Ten prąd nie może przepłyną przez wyłączone elementy przełączające, jednak
 musi znaleźć ujście.
 Diody zabezpieczające są niskorezystancyjną ścieżką dla tych prądów rozładowują
cych i pozwalają utrzymać napięcie na stykach silnika na racjonalnym poziomie.
\end_layout

\begin_layout Standard
Kiedykolwiek dioda przewodzi prąd, następuje na niej relatywnie stały spadek
 napięcia w kierunku przewodzenia określany jako 
\begin_inset Formula $\textrm{U}_{\textrm{F}}$
\end_inset

.
 Napięcie to zawiera się w przedziale 500 do 1000
\begin_inset space ~
\end_inset

mV dla większości elementów.
 Ten spadek napięcia w połączeniu z przepływem prądu powoduje wydzielanie
 ciepła.
 Jego aktualny poziom zależy o średniego prądu przepływającego przez diodę
 i czasu jej otwarcia.
 Jako przykład, jeżeli pole elektromagnetyczne rozładowuje się przez 1
\begin_inset space ~
\end_inset

ms, czas pojedynczego cyklu wynosi 10
\begin_inset space ~
\end_inset

ms, prąd na początku cyklu wyłączenia jest 10
\begin_inset space ~
\end_inset

A i spada liniowo (zakładając obciążenie idealnie indukcyjne), wtedy średni
 prąd 5
\begin_inset space ~
\end_inset

A przepływa przez diodę przez 10% czasu.
 Wydzielane ciepło to 
\begin_inset Formula $5\,\unit{A}\times0,5\,\unit{V}\times10\%=0,25\,\unit{W}$
\end_inset

(zakładając 
\begin_inset Formula $\textrm{U}_{\textrm{F}}=0,5\,\unit{V}$
\end_inset

).
 Jeżeli jednak pole rozładowuje się wolniej, powiedzmy w 5
\begin_inset space ~
\end_inset

ms, wydzielanie ciepła wzrasta do 
\begin_inset Formula $5\,\unit{A}\times0,5\,\unit{V}\times50\%=1,25\,\unit{W}$
\end_inset

.
 Liczby są jeszcze gorsze dla przypadków, gdy pole nie rozładuje się całkowicie
 do końca cyklu wyłączenia.
 Widać wyraźnie, że ilość ciepła wydzielanego przez diody może być tak samo
 istotna, jak ciepło wydzielane na elementach przełączających.
\end_layout

\begin_layout Standard
Jest bardzo istotne widzieć, że o ile dla układów niskiej częstotliwości,
 wybór elementów przełączających jest wymuszony głównie przez maksymalny
 statyczny prąd dostarczany przez mostek, to wybór diod jest bardziej angażujący
 i wymaga analizy aktualnego rozładowywania się pola elektromagnetycznego.
 Wybór diody będzie uzależniony od dynamicznego zachowania mostka.
 Projekt i kontrola mostka ma znaczący wpływ jak długo diody będą przewodzić,
 więc przy jednym rodzaju kontroli mostek może przetrwać większe prący,
 niż w przypadku innego rodzaju.
 W pewnych wypadkach diody nie przewodzą w ogóle.
\end_layout

\begin_layout Standard
Istotną cechą tranzystorów MOSFET jest to, że posiadają nieodłączną (nie
 do uniknięcia) diodę pomiędzy drenem a źródłem.
 Ta dioda działa jak dioda zabezpieczająca w mostku H, a większość specyfikacji
 MOSFETów określa parametry tej diody.
 Tak więc, jest możliwe użycie tej wbudowanej diody tranzystora i nie wprowadzen
ie dodatkowo zewnętrznej, jeżeli specyfikacja tej diody spełnia wymagania
 projektu.
 W przypadku tranzystorów bipolarnych taka wbudowana dioda nie występuje,
 więc zewnętrzna dioda zawsze musi być obecna.
\end_layout

\begin_layout Standard
Diody - głównie, gdy pozostają wyłączone - mają małą pojemność pomiędzy
 swoimi stykami.
 Ta pojemność musi zostać rozładowana zanim urządzenie może się włączy,
 co prowadzi do opóźnień w odpowiedzi na nagłą zmianę napięcia.
 Ta pojemność zależy od wielu współczynników, ogólnie patrząc rośnie wraz
 z powierzchnią złącza P-N, które daje możliwość przewodzenia prądu tej
 diodzie.
 W skrócie, im większa dioda, tym wolniejsza.
 Kiedy mostek się wyłącza, prąd silnika musi dalej płynąć.
 Silnik wymusi na diodzie (lub diodach) przewodzenie, aby utworzyć drogę
 dla tego prądu, jednakże opóźnienie załączenia diody stworzy problem.
 Gorzej, to zdąży się w punkcie, gdzie prąd silnika jest najwyższy.
 Bez złagodzenia napięcia może wzrosnąć do niebezpiecznego poziomi i zniszczyć
 elementy przełączające.
 Aby rozwiązać problem na okres, kiedy ani elementy przełączające, ani diody
 nie nie przewodzą, kondensator musi być podłączony do styków silnika.
 Niektóre silniki posiadają już kondensatory, jednak wiele wymaga zewnętrznych.
 Taki kondensator będzie przewodził prąd do czasu, aż dioda się nie otworzy,
 jednakże napięcie na stykach silnika nadal będzie gwałtownie rosło.
 Jest więc istotne, aby wybierać diody o najkrótszym możliwym czasie załączania,
 co jest powodem, że diody Schottky'ego są najlepsze do tej roli.
\end_layout

\begin_layout Chapter
Narzędzia i moduły
\end_layout

\begin_layout Standard
Rozdział ten opisuje techniczne aspekty narzędzi i modułów planowanych do
 użycia w trakcie realizacji pracy.
 Opracowany materiał pochodzi z ekstrakcji najbardziej użytecznych informacji
 zawartych w dokumentacjach producentów opisywanych narządzi i modułów.
\end_layout

\begin_layout Section
Narzędzia programowe
\end_layout

\begin_layout Subsection
AVR32 Studio
\begin_inset CommandInset label
LatexCommand label
name "sec:AVR32-Studio"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "32mm"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/avr32studio_icon.gif
	width 30mm
	height 30mm
	keepAspectRatio

\end_inset


\end_layout

\end_inset

AVR32 Studio według producenta
\begin_inset CommandInset citation
LatexCommand cite
key "AVR32015"

\end_inset

 jest zintegrowanym środowiskiem programistycznym (ang.
 
\shape italic
\lang british
integrated development environment
\shape default
\lang polish
) do produkcji oprogramowania dla mikrokontrolerów serii AVR32 firmy ATMEL
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

.
 AVR32 Studio udostępnia kompletny zestaw funkcjonalności zawierający m.
\begin_inset space ~
\end_inset

in.:
\end_layout

\begin_layout Itemize
zarządzanie projektem i integrację z kontrolą wersji (CVS)
\end_layout

\begin_layout Itemize
edytor C/C++ z podświetlaniem składni i automatycznym uzupełnianiem kodu
\end_layout

\begin_layout Itemize
wsparcie uruchamiania i debugowania włącznie z krokowym przetwarzaniem kodu
 źródłowego i na poziomie instrukcji maszynowej wraz z pułapkami (ang.
 
\shape italic
\lang british
breakpoints
\shape default
\lang polish
)
\end_layout

\begin_layout Itemize
podgląd rejestrów, pamięci oraz wejścia i wyjścia
\end_layout

\begin_layout Itemize
konfigurację platformy docelowej i zarządzanie nią.
\end_layout

\begin_layout Standard
AVR32 Studio jest określane terminem 
\lang british
Built
\begin_inset space ~
\end_inset

On
\begin_inset space ~
\end_inset

Eclipse
\lang polish

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
texttrademark}
\end_layout

\end_inset

 (pol.
 
\shape italic
zbudowane na Eclipse
\shape default
), oznaczającym możliwości łatwej integracji z rozszerzeniami zewnętrznymi
 w celu zwiększania funkcjonalności środowiska pracy.
\end_layout

\begin_layout Standard
AVR32 Studio wspiera wszystkie rodzaje układów mikrokontrolerów z serii
 AVR32.
 Umożliwia pracę nad projektami samodzielnymi bez systemu operacyjnego lub
 z systemem integrowanym w projekcie (np.
 FreeRTOS
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
texttrademark}
\end_layout

\end_inset

 lub ThreadX
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

 firmy Express Logic) oraz projektów będących aplikacjami systemu Linux
 (dla rodziny AT32AP7).
\end_layout

\begin_layout Standard
Wszystkie narzędzia firmy Atmel, które wspierają architekturę AVR32 włączając
 w to JTAG ICE mk-II (patrz: podrozdział 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE"

\end_inset

), AVR
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

ONE! oraz STK
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

600 są wspierane przez AVR32 Studio.
\end_layout

\begin_layout Standard
AVR32 Studio wspiera również wszystkie płyty firmy ATMEL przewidziane dla
 systemu Linux, takie jak STK1000 i NGW100.
 Aby uruchamiać i debugować system docelowy potrzebne jest połączenie sieciowe
 pomiędzy komputerem a płytą.
 AVR32 Studio integruje się z łańcuchem narzędzi GNU (ang.
 
\shape italic
\lang british
GNU Toolchain
\shape default
\lang polish
) dla AVR32, których przygotowanie jest krótko omówione w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:prep-AVR32-Toolchain"

\end_inset

.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Środowisko-ramowe"

\end_inset

Środowisko ramowe
\end_layout

\begin_layout Standard
(ang.
 
\shape italic
\lang british
framework
\shape default
\lang polish
)
\end_layout

\begin_layout Subsection
Doxygen
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Stworzyć opis Doxygen'a
\end_layout

\end_inset


\end_layout

\begin_layout Section
Narzędzia sprzętowe
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:JTAG-ICE"

\end_inset

JTAG ICE mk-II
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement R
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/jtag-ice-mkii-bw-scaled.jpg
	lyxscale 50
	width 40col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fotografia JTAG
\begin_inset space ~
\end_inset

ICE
\begin_inset space ~
\end_inset

mk-II
\end_layout

\end_inset


\end_layout

\end_inset

Urządzenie AVR
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

 JTAG ICE mk-II z firmy Atmel jest silnym narzędziem do On-chip Debugging
 wszystkich typów 8-bitowych mikrokontrolerów AVR RISC z interfejsem IEEE
 1149.1 (opisany w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Interfejs-JTAG"

\end_inset

) lub interfejsem debugWIRE.
 Interfejs DebugWIRE pozwala na debugowanie układów o małej liczbie wyprowadzeń
 dzięki użyciu tylko jednej linii sygnałowej do komunikacji.
 JTAG ICE mk-II wraz z programem AVR Studio daje do ręki użytkownika kompletną
 kontrolę nad wewnętrznymi zasobami mikrokontrolera, skracając czas uruchamiania
 poprzez uczynienie debugowania łatwiejszym.
 Możliwe jest także emulowanie mikrokontrolera w czasie rzeczywistym, w
 trakcie jego działania w systemie docelowym.
\end_layout

\begin_layout Standard
Dzięki temu narzędziu zasoby mikrokontrolera AVR mogą być monitorowane:
 pamięć Flash, pamięć EEPROM, pamięć SRAM, rejestry, licznik programu, bity
 blokujące i zabezpieczające, oraz wszystkie moduły wejścia/wyjścia.
 Wspierane jest także rozległe wsparcie dla warunków zatrzymania, włączając
 w to zmianę przepływu w programie, zmianę komórek pamięci pod konkretnym
 adresem lub zakresami adresów.
\end_layout

\begin_layout Standard
Oprócz debugowania istotną funkcją realizowaną przez JTAG ICE mk-II jest
 programowanie pamięci Flash i EEPROM mikrokontrolerów AVR
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textsuperscript{
\backslash
textregistered}
\end_layout

\end_inset

 i AVR32.
 Chcąc programować układy AVR32 z pominięciem funkcjonalności programu startoweg
o niezbędne jest posiadanie takiego właśnie urządzenia.
 Elastyczne ustawianie i kasowanie bitów zabezpieczających w tej serii układów,
 jest możliwe tylko z tym narzędziem.
\end_layout

\begin_layout Standard
Integracja ze środowiskiem AVR32 Studio obejmuje poza programowaniem układów
 i debugowaniem, również aktualizację oprogramowania w samym urządzeniu.
 Aplikacja ta bazuje na uznanym standardzie środowisk programistycznych,
 czyli Eclipse.
\end_layout

\begin_layout Section
Moduły
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:EVK1100"

\end_inset

Zestaw EVK1100
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0col%
width "40col%"
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename images/evk1100-angle.jpg
	lyxscale 50
	width 40col%
	BoundingBox 10bp 10bp 400bp 349bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Fotografia EVK1100"

\end_inset

Fotografia EVK1100
\end_layout

\end_inset


\end_layout

\end_inset

Zestaw uruchomieniowy EVK1100 pokazany na rysunku 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Fotografia EVK1100"

\end_inset

 stanowi kontrolną jednostkę bazową dla systemu sterowania robotem, którego
 praktyczna realizacja jest opisana w części 
\begin_inset CommandInset ref
LatexCommand vref
reference "par:Realizacja-praktyczna"

\end_inset

.
 Konstrukcja płyty jest oparta o układ mikrokontrolera Atmel AT32UC3A0512
 opisany w rozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Mikrokontroler-AT32UC3A0512"

\end_inset

.
 Została zaprojektowana w sposób umożliwiający projektantowi urządzenia
 uruchomienie oprogramowania realizującego planowaną funkcjonalność na dostępnyc
h peryferiach.
 Następnie tak uruchomiony projekt może zostać przeniesiony na docelową
 płytę urządzenia, do zaprojektowania której zestaw EVK1100 może stanowić
 dobrą konstrukcję referencyjną.
\end_layout

\begin_layout Standard
Płyta zawiera następujące układy peryferyjne zainstalowane i gotowe do użycia
 przez programistę:
\end_layout

\begin_layout Itemize
Interfejs USB (2.0 mini A-B receptacle)
\end_layout

\begin_layout Itemize
Interfejs Ethernet (External Ethernet Phy 10/100 and gniazdko RJ45)
\end_layout

\begin_layout Itemize
3 × Zegar
\end_layout

\begin_layout Itemize
1 × Atmel DataFlash (AT35DB642 8 MBytes, współdzielony z SPI1)
\end_layout

\begin_layout Itemize
1 × SDRAM (32 MBytes)
\end_layout

\begin_layout Itemize
2 × USARTs
\end_layout

\begin_layout Itemize
Wyświetlacz LCD 4x20 (niebieski, z podświetlaniem regulowanym PWM)
\end_layout

\begin_layout Itemize
6 × LEDs
\end_layout

\begin_layout Itemize
3 × Przyciski
\end_layout

\begin_layout Itemize
1 × Joystick
\end_layout

\begin_layout Itemize
1 × Potencjometr
\end_layout

\begin_layout Itemize
1 × Czujnik światła
\end_layout

\begin_layout Itemize
1 × Czujnik temperatury
\end_layout

\begin_layout Itemize
2 × SPI (Serial Peripheral Interface), w tym jeden wolny
\end_layout

\begin_layout Itemize
1 × Slot SD/MMC (poprzez SPI0)
\end_layout

\begin_layout Itemize
1 × TWI (Two Wire Interface) 
\end_layout

\begin_layout Standard
Sterowanie silników elektrycznych jest możliwe dzięki 6 wyjściom PWM oferowanym
 przez układ AT32UC3A0512.
\end_layout

\begin_layout Subsection
Moduł kamery PixelPlus
\end_layout

\begin_layout Standard
System 
\begin_inset Quotes pld
\end_inset

wzroku
\begin_inset Quotes prd
\end_inset

 robota oparty jest o kamerę cyfrową PIXELPLUS PO2030NC-MS21-PP03 z matrycą
 CMOS o rozmiarze 1/4.5
\begin_inset Quotes prd
\end_inset

 (5,64 mm) i rozdzielczości efektywnej 640
\begin_inset Formula $\times$
\end_inset

480 punktów.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename vector/camera-dimensions.svg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Rozmiary kamery PIXELPLUS
\end_layout

\end_inset


\end_layout

\end_inset

 Ta bardzo małych rozmiarów kamera może rejestrować obraz kolorowy lub w
 odcieniach szarości.
 Kąt widzenia optyki tej kamery to 63
\begin_inset Formula $^{\circ}$
\end_inset

 co odpowiada długości ogniskowej 35
\begin_inset space ~
\end_inset

mm obiektywu aparatu małoobrazkowego
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Pod pojęciem aparat fotograficzny małoobrazkowy kryje się format obrazka
 36
\begin_inset Formula $\times$
\end_inset

24
\begin_inset space ~
\end_inset

mm kliszy fotograficznej.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Moduł Bluetooth
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Stworzyć prosty opis modułu Bluetooth i zawartego układu dodać referencję
 do rozruchu.
\end_layout

\end_inset


\end_layout

\begin_layout Part
\begin_inset CommandInset label
LatexCommand label
name "par:Realizacja-praktyczna"

\end_inset

Realizacja praktyczna
\end_layout

\begin_layout Chapter
Przygotowanie środowiska pracy
\end_layout

\begin_layout Section
AVR32 Toolchain
\begin_inset CommandInset label
LatexCommand label
name "sec:prep-AVR32-Toolchain"

\end_inset


\end_layout

\begin_layout Standard
Do realizacji procesu produkcji oprogramowania dla urządzenia mikroprocesorowego
 niezbędne jest posiadanie łańcucha narzędzi (ang.
 
\shape italic
\lang british
toolchain
\shape default
\lang polish
) dedykowanych dla danego typu procesora.
 Zestaw taki składa się między innymi z:
\end_layout

\begin_layout Itemize
assemblera skrośny (ang.
 
\shape italic
\lang british
cross assembler
\shape default
\lang polish
)
\end_layout

\begin_layout Itemize
kompilatora skrośny (ang.
 
\shape italic
\lang british
cross compiler
\shape default
\lang polish
) język C i/lub języka C++
\end_layout

\begin_layout Itemize
linkera
\end_layout

\begin_layout Itemize
zdalnego debuggera dla procesora wbudowanego
\end_layout

\begin_layout Itemize
narzędzi do programowania pamięci flash mikrokontrolera
\end_layout

\begin_layout Itemize
i kilku dodatkowych do obsługi bibliotek.
\end_layout

\begin_layout Standard
W przypadku procesora AT32UC3A0512 firma Atmel udostępnia nieodpłatnie
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118
\end_layout

\end_inset

 zestaw narzędzi bazujących na znanym kompilatorze GNU GCC.
 Kompilator GNU C (GCC) jest stosowany do kompilacji kodu źródłowego w językach
 C i C++, natomiast GNU debugger (GDB) ma zastosowanie do uruchamiania i
 debugowania aplikacji na platformie docelowej.
\end_layout

\begin_layout Standard
Zestaw ten jest również wyposażony w sterowniki USB pozwalające na podpięcie
 układów na bazie procesorów serii AVR32.
 Narzędzie 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=bash"
inline true
status collapsed

\begin_layout Plain Layout

avr32program
\end_layout

\end_inset

 służy do zaprogramowania układu i wykonanie nastaw konfiguracyjnych napięć
 i zegara poprzez JTAG, natomiast narzędzie 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=bash"
inline true
status collapsed

\begin_layout Plain Layout

avr32gdbproxy
\end_layout

\end_inset

 jest używane do połączenia aplikacji debuggera z systemem docelowym.
\end_layout

\begin_layout Standard
Aby rozpocząć pracę nad kompilacją i uruchomieniem kodu niezbędna jest instalacj
a tego zestawu z pomocą instalatora dostępnego na stronie firmy Atmel.
 Narzędzia te są niezbędne do prawidłowego korzystania ze środowiska AVR32
 Studio omówionego w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:prep-AVR32-Toolchain"

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:prep-AVR32-Studio"

\end_inset

.
 Przykładowe zastosowanie omawianych powyżej narzędzi opisane jest w podrozdzial
e 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:EVK1100-rozruch"

\end_inset

.
\end_layout

\begin_layout Section
AVR32 Studio
\begin_inset CommandInset label
LatexCommand label
name "sec:prep-AVR32-Studio"

\end_inset


\end_layout

\begin_layout Subsection
Instalacja
\end_layout

\begin_layout Standard
Omówione w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:AVR32-Studio"

\end_inset

 środowisko programistyczne AVR32 Studio wymaga instalacji.
 Aplikacja instalacyjna jest dostępna na stronie firmy Atmel nieodpłatnie
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4116
\end_layout

\end_inset

 po dokonaniu rejestracji swoich danych.
 Ponieważ Eclipse na którym bazuje AVR32 Studio jest aplikacją Java, na
 komputerze musi być zainstalowane środowisko Java (ang.
 
\shape italic
\lang british
Java Runtime Environment
\shape default
\lang polish
, w skrócie JRE).
\end_layout

\begin_layout Standard
Przed rozpoczęciem instalacji AVR32 Studio dobrze jest mieć zainstalowane
 narzędzia GNU dla AVR32 wspomniane w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:prep-AVR32-Toolchain"

\end_inset

, choć przy uruchomieniu program samoczynnie wykryje brak odpowiednich narzędzi
 w minimalnej wymaganej wersji.
\end_layout

\begin_layout Standard
Pierwsze uruchomienie wykonuje także automatyczną aktualizację komponentów
 środowiska Eclipse z których składa się AVR32 Studio.
 Proces ten uruchamiany jest w tle, co możemy zaobserwować w formie małej
 animacji w prawym dolnym rogu z procentowym wyrażeniem postępu analizy
 dostępnych uaktualnień.
 W przypadku znalezienia aktualizacji pojawi się okno dialogowe z pytaniem,
 czy przejrzeć dostępne aktualizacje.
 Po potwierdzeniu dostępne jest drzewo grup komponentów, które zawierają
 jakieś aktualizacje.
 Można zaznaczyć, które chce się zainstalować.
\end_layout

\begin_layout Standard
AVR32 udostępnia krótkie kursy postępowania w realizacji podstawowych zadań
 dostępne z głównego ekranu zaraz po uruchomieniu aplikacji.
\end_layout

\begin_layout Subsection
Przygotowanie terminala
\end_layout

\begin_layout Standard
Środowisko AVR32 Studio udostępnia narzędzia terminala, które może być bardzo
 pomocne w pracy.
 W przypadku EVK1100, potrzebny będzie terminal szeregowy.
 Wymaga od jednak do pracy dodatkowej biblioteki RXTX na licencji GPL, którą
 należy zainstalować samodzielnie.
 Do pobrania z następującego adresu: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://rxtx.qbang.org/pub/rxtx/rxtx-2.1-7-bins-r2.zip
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Następnie pliki zawarte z archiwum należy umieścić w odpowiednich katalogach
 (katalog JRE podany przykładowo):
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
RXTXcomm.jar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C:
\backslash
Program Files
\backslash
Java
\backslash
jre_1.6.0_06
\backslash
lib
\backslash
ext
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
rxtxSerial.dll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C:
\backslash
Program Files
\backslash
Java
\backslash
jre_1.6.0_06
\backslash
bin
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
rxtxParallel.dll
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C:
\backslash
Program Files
\backslash
Java
\backslash
jre_1.6.0_06
\backslash
bin
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Dopiero po instalacji tych plików możliwe będzie stosowanie terminala szeregoweg
o połączonego przez port RS232 komputer z portem RS232 na płytce EVK1100.
\end_layout

\begin_layout Chapter
Rozruch modułów
\end_layout

\begin_layout Standard
Przed przystąpieniem do zasadniczej pracy nad projektem złożonym ze wszystkich
 komponentów wchodzących w skład całości opisywanego systemu, poszczególne
 moduły muszą być uruchomione i wstępnie przetestowane przed przystąpieniem
 do ich wzajemnej integracji.
 Rozdział ten omawia procedury rozruchowe najważniejszych komponentów i
 narzędzi zastosowanych w realizacji całości projektu opisanej w kolejnych
 rozdziałach.
\end_layout

\begin_layout Section
JTAG ICE mk-II + STK 500
\begin_inset CommandInset label
LatexCommand label
name "sec:JTAG-ICE-rozruch"

\end_inset


\end_layout

\begin_layout Standard
STK500 jest kartą rozwojową i zestawem startowy dla mikrokontrolerów z linii
 AVR firmy ATMEL .
 Jest to produkt o uznanej rynkowej pozycji, stosowany od kilku lat jako
 układ rozruchowy dla aplikacji mikrokontrolerów AVR, głównie ATMEGA i ATtiny
 (omówione w rozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:AVR-serie"

\end_inset

).
 Płytka zawiera podstawki dla kilku najpopularniejszych typów układów w
 obudowach DIP oraz trochę elektroniki służącej do sterowania zasilaniem,
 komunikacją RS-232 i programowaniem w systemie (ISP).
 Atrakcyjny zestaw inżynierski dostępny w promocji w roku 2007 nie zamyka
 się w samym STK500, ale zawiera również JTAG ICE mk-II opisane dokładniej
 w 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE"

\end_inset

.
 
\end_layout

\begin_layout Standard
Uruchomienie samego STK500 z domyślnie zainstalowanym układem ATMEGA8515L
 przebiega bezproblemowo.
 Zapinamy za pomocą dostępnych tasiemek złącze PORTB do złącza LEDS i złącze
 PORTD do złącza SWITCHES.
 Po podłączeniu zasilania powinien być dostępny domyślny program pozwalający
 za pomocą przycisków sterować diodkami.
 Jest to postępowanie dokładnie zgodne z krokami opisanymi w instrukcji
 użytkownika.
 Aby zaprogramować układ w podstawce STK500 (oznaczenie SCKT3000D3) należy
 za pomocą tasiemki podłączyć złącze ISP6PIN ze złączem SPROG3.
 Po podłączeniu zasilania i kabla RS-232 do gniazda RS232CTRL i komputera
 PC możemy przeprowadzać programowanie układu w 
\series bold
AVR Studio
\series default
.
 Przeprowadzamy to przez kliknięcie ikonki oznaczonej “AVR” na pasku narzędzi.
 Dokładny opis procesu dostępny jest w dokumentacji użytkownika.
\end_layout

\begin_layout Standard
Układ ATMEGA8515L nie posiada żadnych elementów JTAG ani wsparcia dla sprzętoweg
o debugowania.
 Aby wypróbować możliwości ICE mk-II należy zamontować w podstawce układ
 ATMEGA162V dostępny standardowo w aktualnie dostarczanych zestawach STK500.
 W tym układzie mamy dostęp do pełnego standardu IEEE 1149.1 oraz sprzętowego
 debugowania i programowania pamięci Flash, EEPROM, fuse- i lock-bitów.
 Aby układ ATMEGA162V współpracował z JTAG ICE mk-II należy podłączyć próbnik
 do płytki STK500, przy czym w tym konkretnym wypadku wymaga do podłączenia
 samodzielnego -- STK500 nie posiada portu dla JTAG.
 Podłączenia należy dokonać przez wyprowadzenia ze złącza PORTC i jednego
 pinu złącza PORTE (pin RST).
\end_layout

\begin_layout Section
RoboActor
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Section
EVK1100
\begin_inset CommandInset label
LatexCommand label
name "sec:EVK1100-rozruch"

\end_inset


\end_layout

\begin_layout Standard
Uruchomienie układu rozwojowego EVK1100 firmy Atmel po wyjęciu z pudełka
 przeprowadzamy w dwóch etapach, z których pierwszy polega na podłączeniu
 zasilania do płytki zgodnie z ulotką zatytułowaną 
\begin_inset Quotes eld
\end_inset

Quick Start Guide
\begin_inset Quotes erd
\end_inset

 i sprawdzeniu działania aplikacji testowej preinstalowanej przez producenta.
 W następnym kroku przeprowadzamy kompilację programu testowego ze źródeł
 oraz ładowanie kodu binarnego na płytkę za pomocą JTAG ICE mk-II (opisanego
 w sekcji 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE"

\end_inset

 oraz sekcji 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:JTAG-ICE-rozruch"

\end_inset

).
\end_layout

\begin_layout Description
Krok
\begin_inset space ~
\end_inset

1.
 Przygotowanie zestawu narzędzi GNU Compiler Collection dla AVR32
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
Zestaw narzędzi dostępny na 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.atmel.com/avr32
\end_layout

\end_inset


\end_layout

\end_inset

 zawierającego między innymi kompilator gcc i debugger gdb dla procesora
 AVR32.
 Dodatkowo z płytki CD dostarczonej z zestawem EVK1100 lub ze strony producenta
 ściągamy bibliotekę kodu dla procesora typu UC3.
\end_layout

\begin_layout Description
Krok
\begin_inset space ~
\end_inset

2.
 Następnie przykładowy kod z katalogu 
\family typewriter
/praca/framework/APPLICATIONS/EVK1100-CONTROL_PANEL/AT32UC3A/GCC
\family default
 budujemy poleceniem 
\family typewriter
make
\family default
.
 Uruchamia ono kompilator 
\family typewriter
avr32-gcc
\family default
 i tworzy wynikowy plik relokowalny 
\family typewriter
uc3a0512-ctrlpanel.elf
\family default
.
\end_layout

\begin_layout Description
Krok
\begin_inset space ~
\end_inset

3.
 Kasowanie pamięci mikrokontrolera przeprowadzamy poleceniem avr32program,
 którego wywołanie wygląda następująco:
\begin_inset Newline newline
\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "90text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
avr32program chiperase
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Usuwa to zabezpieczenia pamięci flash mikrokontrolera i pozwala na zapisanie
 nowego programu binarnego do tej pamięci.
\end_layout

\end_deeper
\begin_layout Description
Krok
\begin_inset space ~
\end_inset

4.
 Ładowanie programu dokonujemy poleceniem 
\family typewriter
avr32program
\family default
, którego przykładowe wywołanie wygląda następująco:
\begin_inset Newline newline
\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "90text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
avr32program program -finternal@0x80000000,512Kb -e -v uc3a0512-adc_example.elf
 
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

w rezultacie kod binarny zostaje zaprogramowany w pamięci flash procesora.
 Zastosowane opcje programu informują programator, że adres pamięci programowaln
ej zaczyna się pod adresem 0x80000000 i ma rozmiar 512
\begin_inset space ~
\end_inset

kilobajtów.
 Opcja -e informuje o wykasowaniu pamięci przed programowaniem, a opcja
 -v o przeprowadzeniu weryfikacji programowania.
\end_layout

\begin_layout Standard
Aby od tego momentu przystąpić do pracy nad projektem w 
\series bold
AVR32 Studio
\series default
, należy przygotować środowisko pracy, na które składają się:
\end_layout

\begin_layout Itemize
elementy szkieletu aplikacji (ang.
 
\lang british
application framework
\lang polish
)
\end_layout

\begin_layout Itemize
system operacyjny FreeRTOS wersja 4.8.0
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
Firma Atmel dostarczyła w szkielecie FreeRTOS w wersji 4.3.1.
 Znajduje się on w katalogu 
\family typewriter
praca/framework/SERVICES/FREERTOS
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ze względu na pewne ograniczenia i niedogodności w zarządzaniu projektem
 w 
\series bold
AVR32 Studio
\series default
 wszystkie elementy składające się na aplikację muszą znaleźć się w jednym
 katalogu.
 Polega to na skopiowaniu wybranych sterowników (ang.
 
\shape italic
\lang british
drivers
\shape default
\lang polish
) i innych potrzebnych elementów ze szkieletu dostarczonego przez firmę
 Atmel.
 Zamiast systemu FreeRTOS dostarczonego ze szkieletem, załadowany został
 system zciągnięty ze strony 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.freertos.org
\end_layout

\end_inset

 i umieszczony w katalogu 
\family typewriter
praca/src/FREERTOS
\family default
, usunięte zostały porty inne niż 
\family typewriter
AVR32_UC3
\family default
 z podkatalogu 
\family typewriter
portable/GCC
\family default
.
 Ze szkieletu z podkatalogu 
\family typewriter
SERVICES/FREERTOS/portable
\family default
 przeniesiony został katalog 
\family typewriter
MemMang
\family default
 z plikiem 
\family typewriter
heap3.c
\family default
 do odpowiadającego katalogu projektu.
\end_layout

\begin_layout Standard
Jako bazę wybrana zostaje aplikacja Control Panel, która następnie jest
 budowana pod kontrolą 
\series bold
AVR32 Studio
\series default
, jako projekt typu AVR32 Managed Make.
 Przed zbudowaniem aplikacji, należy przekonfigurować nieco sposób kompilacji
 pliku 
\family typewriter
exception.S
\family default
 z katalogu 
\family typewriter
DRIVERS/INTC
\family default
:
\end_layout

\begin_layout Itemize
zmieniać nazwę pliku 
\family typewriter
exception.S
\family default
 na nazwę 
\family typewriter
exception.s
\end_layout

\begin_layout Itemize
z menu prawego przycisku myszy wybrać 
\begin_inset Quotes pld
\end_inset

Properties
\begin_inset Quotes prd
\end_inset


\end_layout

\begin_layout Itemize
wybrać opcję 
\begin_inset Quotes pld
\end_inset

C/C++ Build item"
\end_layout

\begin_layout Itemize
w zakładce 
\begin_inset Quotes pld
\end_inset

Tool Settings" wybrać element 
\begin_inset Quotes pld
\end_inset

AVR32/GNU Assembler"
\end_layout

\begin_layout Itemize
zmienić 
\family typewriter
avr32-as
\family default
 na 
\family typewriter
avr32-gcc
\end_layout

\begin_layout Itemize
wybrać podelement 
\begin_inset Quotes pld
\end_inset

General"
\end_layout

\begin_layout Itemize
dodać w polu 
\begin_inset Quotes pld
\end_inset

Assembler Flags" wartość 
\family typewriter
-x assembler-with-cpp -c
\family default
 
\end_layout

\begin_layout Standard
Od tego momentu projekt jest gotowy do przebudowania w całości.
 Zbudowanie całej aplikacji zajmuje kilkanaście minut.
\end_layout

\begin_layout Section
Moduł Bluetooth
\end_layout

\begin_layout Standard
W celu uruchomienia modułu Bluetooth niezbędne okazało się podłączenie go
 za pośrednictwem interfejsu RS232 do komputera w celu skomunikowania się
 z logiką modułu.
 Dzięki temu możliwe stało się wprowadzenie nastaw wstępnych do pamięci
 Flash modułu, które umożliwiają bezproblemową komunikację modułu z UART
 mikrokontrolera AT32UC3A0512.
 Dodatkowo możliwe jest też łatwiejsze testowanie protokołów komunikacyjnych
 działających na takim łączu szeregowym.
\end_layout

\begin_layout Standard
Ponieważ zastosowany w projekcie moduł Bluetooth działa w napięciu 3,3
\begin_inset space ~
\end_inset

V, to fizyczna interakcja interfejsu RS232 z logiką 3,3
\begin_inset space ~
\end_inset

V modułu wymagała wykonania układu przejściowego według schematu z rysunku
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-modułu-konwertera-RS232"

\end_inset

 opartego na układzie konwertera MAX3243CAI.
 Pozwala to na podłączenie modułu do gniazda portu szeregowego w komputerze
 PC oraz do gniazda karty EVK1100 na czas prac uruchomieniowych.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/rs232_bluetooth.svg
	width 99text%
	BoundingBox 51bp 180bp 648bp 488bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-modułu-konwertera-RS232"

\end_inset

Schemat modułu konwertera RS232
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dla powyższego układu wykonana została płytka drukowana, której projekt
 prezentowany jest na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Projekt-PCB-konwertera-RS232"

\end_inset

.
 Zbudowanie układu na płytce drukowanej umożliwiło łatwiejsze wykorzystanie
 elementów elektronicznych montowanych powierzchniowo (ang.
 
\shape italic
\lang british
surface mounted device
\shape default
\lang polish
, w skrócie SMD).
 Podyktowane to było możliwością zdobycia układu dopasowującego MAX3243
 poziomy RS232 do logiki 3.3V tylko w wersji SMD.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Strona elementów
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../schematics/rs232_bluetooth/rs232_bluetooth-Elementów.ps
	BoundingBox 120bp 450bp 296bp 553bp
	clip
	rotateOrigin leftTop

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Strona ścieżek
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../schematics/rs232_bluetooth/rs232_bluetooth-Ścieżek.ps
	BoundingBox 120bp 450bp 296bp 553bp
	clip
	rotateOrigin leftTop

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Rozkład elementów
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../schematics/rs232_bluetooth/rs232_bluetooth-Opisu_górna.ps
	BoundingBox 120bp 450bp 296bp 553bp
	clip
	rotateOrigin leftTop

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Projekt-PCB-konwertera-RS232"

\end_inset

Projekt płytki drukowanej modułu konwertera RS232
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uruchomienie modułu konwertera po jego złożeniu okazało bardzo problematyczne.
 Standardowe ustawienia prędkości pracy układu UART moduły Bluetooth okazały
 się być inne, niż określone w dokumentacji producenta (referencja).
 W dokumentacji mowa jest o prędkości 115200 bitów/s, w rzeczywistości UART
 skonfigurowany był dla 9600 bitów/s.
 Ustawienia prędkości portu wirtualnego działającego na Bluetooth po stronie
 komputera PC nie ma znaczenia dla działania komunikacji.
\end_layout

\begin_layout Standard
Do uruchamiania modułu użyto programu TeraTerm
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
Aktualne wersje tego narzędzia dostępne pod adresem http://ttssh2.sourceforge.jp/
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://ttssh2.sourceforge.jp/
\end_layout

\end_inset

.
\end_layout

\end_inset

.
 Można użyć jednak dowolnego programu poprawnie obsługującego komunikację
 szeregową w komputerach PC.
\end_layout

\begin_layout Standard
Tryb komend modułu Bluetooth jest osiągalny tylko za pośrednictwem UART,
 czyli od strony zbudowanego konwertera RS232 na logikę 3,3
\begin_inset space ~
\end_inset

V.
 Przypomina to pracę klasycznego modemu.
 Ciąg znaków, powodujących przejście do trybu komend to 
\begin_inset Quotes pld
\end_inset

+++
\begin_inset Quotes prd
\end_inset

 (trzy znaki plus), który można zrekonfigurować na inny ciąg właściwą komendą.
 Spis komend znajduje się w dokumentacji moduły Bluetooth (referencja).
\end_layout

\begin_layout Section
Moduł kamery
\end_layout

\begin_layout Standard
W aktualnej realizacja moduł kamery nie został zastosowany, ze względu na
 czas i koszty implementacji współpracy kamery z mikrokontrolerem.
\end_layout

\begin_layout Chapter
Sterowanie elektromechaniki
\end_layout

\begin_layout Section
Silniki elektryczne robota
\end_layout

\begin_layout Standard
Rozdział 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Silniki-elektryczne"

\end_inset

 omawia konstrukcję silnika prądu stałego.
 Sterowanie zasilaniem siedmiu silników robota odbywa się za pośrednictwem
 układów sterowników MOSFET firmy Microchip, model TC4424A opisanymi w 
\begin_inset CommandInset citation
LatexCommand cite
key "tc4424a-datasheet"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Coś tu dodać o silniczkach?
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Moduł-sterowania-zasilaniem"

\end_inset

Moduł sterowania zasilaniem silników
\end_layout

\begin_layout Standard
Układ TC4424A jest przedstawicielem podwójnych sterowników MOSFET (ang.
 
\shape italic
\lang british
dual MOSFET driver
\shape default
\lang polish
) sterowanych poziomami logicznymi.
 Konstrukcja podwójna pozwala na wybór polaryzacji na wyjściu.
 Układ ten posiada następujące parametry:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features booktabs="true">
<column alignment="right" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zakres napięć pracy:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.5
\begin_inset space ~
\end_inset

V do 18
\begin_inset space ~
\end_inset

V
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Maksymalny prąd chwilowy:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4500
\begin_inset space ~
\end_inset

mA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Czas wysterowania przy zadanej pojemności wyjścia:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\begin_inset space ~
\end_inset

nS przy 1800
\begin_inset space ~
\end_inset

pF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pobór prądu:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.0
\begin_inset space ~
\end_inset

mA przy logicznym 
\begin_inset Quotes pld
\end_inset

1
\begin_inset Quotes prd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\begin_inset space ~
\end_inset

µA przy logicznym 
\begin_inset Quotes pld
\end_inset

0
\begin_inset Quotes prd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Impedancja wyjścia:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.5
\begin_inset space ~
\end_inset

Ω
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Napięcie logicznej jedynki:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> 2.4
\begin_inset space ~
\end_inset

V
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Wewnętrzna architektura układu jest przedstawiona na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architektura-wewnętrzna-TC4424A"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement bh
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/tc4424a-diagram.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architektura-wewnętrzna-TC4424A"

\end_inset

Architektura wewnętrzna TC4424A
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Dopisać:
\end_layout

\begin_layout Enumerate

\color cyan
Skrótowy opis TC4424A
\end_layout

\begin_layout Enumerate
Schemat modułu zasilania silników i opis działania
\end_layout

\begin_layout Enumerate
Obrazek płytki, zdjęcie modułu.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Moduł sterowania zasilaniem silników elektrycznych składa się z siedmiu
 układów TC4424A, których wejścia są połączone z wyprowadzeniami GPIO mikrokontr
olera, zaś wyjścia poprzez diody Schottky'ego połączone są ze stykami komutatoró
w opisanych w 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Komutator"

\end_inset

.
 Opis połączeń wyprowadzeń wejściowych znajduje się w tabeli 
\begin_inset CommandInset ref
LatexCommand vref
reference "tab:wyprowadzenia-pwm"

\end_inset

.
 Schemat modułu przedstawia rysunek 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Schemat-modułu-zasilania-silników"

\end_inset

, zaś rysunki 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Schemat-modułu-zasilania-silników"

\end_inset

 prezentują projekt obu stron płytki drukowanej modułu (rzut od strony elementów
).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement b
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/motor_drivers.svg
	width 101col%
	BoundingBox 5mm 5mm 257mm 180mm
	clip
	rotateAngle 90

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-modułu-zasilania-silników"

\end_inset

Schemat modułu zasilania silników elektrycznych
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../schematics/motor_drivers/motor_drivers-Elementów.ps
	width 98col%
	BoundingBox 10mm 130mm 120mm 210mm
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Strona elementów
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../schematics/motor_drivers/motor_drivers-Ścieżek.ps
	width 98col%
	BoundingBox 10mm 130mm 120mm 210mm
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Strona ścieżek
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Projekt-PCB-modułu-zasilania-silników"

\end_inset

Projekt płytki drukowanej modułu zasilania silników
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diody Schottky'ego na schemacie pełnią rolę zabezpieczeń wyjść tranzystorów
 MOSFET pracujących wewnątrz TC4424A przed impulsami o wysokim napięciu
 indukowanych na zwojach twornika, gdy odłączane jest napięcie zasilające,
 bądź pojawia się zewnętrzny moment napędowy.
\end_layout

\begin_layout Standard
Zastosowany na schemacie układ par tranzystorów połączonych z obciążeniem
 nazywany jest 
\emph on
mostkiem H
\emph default
.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Może odnieść do: http://www.modularcircuits.com/h-bridge_secrets1.htm
\end_layout

\end_inset

 Jest to najpopularniejszy układ sterujący dla silników elektrycznych powszechni
e stosowany w sterowaniu silników jednofazowych.
\end_layout

\begin_layout Standard
Wyprowadzenia końcówek sterujących zasilaniem silników elektrycznych są
 połączone (w większości wypadków) z oryginalnymi wyprowadzeniami zastosowanymi
 w okablowaniu oryginalnym robota.
 W przypadku silników w ramionach robota i silników w korpusie sterujących
 ramionami, kolory przewodów zasilających silniki to niebieski i zielony.
 W przypadku silnika sterującego biodrem, to kolory zółty i zielony.
 Silniki nóg są podłączony przewodami w kolorach czarnym i czerwonym.
\end_layout

\begin_layout Section
Sterowanie cyfrowe silników elektrycznych
\end_layout

\begin_layout Standard
Sterowanie silników elektrycznych napędzających mechaniczne elementy robota
 odbywa się za pomocą siedmiu sterowników PWM (ang.
 
\shape italic
\lang british
pulse width modulation
\shape default
\lang polish
), w które wyposażony jest mikrokontroler AT32UC3A0512.
 Aby umożliwić pracę dwukierunkową, oprócz wyprowadzeń PWM potrzebne są
 dodatkowe wyprowadzenia logiczne.
 Wybór logicznego stanu wysokiego i niskiego oraz odpowiedniej polaryzacji
 PWM będą służyć do zmiany kierunku obrotów.
 Tabela 
\begin_inset CommandInset ref
LatexCommand vref
reference "tab:wyprowadzenia-pwm"

\end_inset

 pokazuje, które wyprowadzenia mikroprocesora wraz z ich nazwami na szynie
 modułu EVK1100 zostały użyte do tego celu.
 Zestawienie to zostało przygotowane na podstawie tabel 7-1, 12-9 oraz 22-2
 z dokumentacji mikrokontrolera 
\begin_inset CommandInset citation
LatexCommand cite
key "uc3a-datasheet"

\end_inset

.
 Kolumna 
\begin_inset Quotes pld
\end_inset

Funkcja
\begin_inset Quotes prd
\end_inset

 podaje oznaczenie funkcji peryferyjnej, w przypadku wyprowadzeń logicznych,
 stanem wyprowadzenia steruje rejestr GPIO.
 Kolumna 
\begin_inset Quotes pld
\end_inset

GPIO
\begin_inset Quotes prd
\end_inset

 określa, która funkcja wyprowadzenia jest wybierana przy programowaniu
 PM (ang.
 
\shape italic
\lang british
Power Manager
\shape default
\lang polish
).
 Nazwa w pierwszej kolumnie określa funkcję sterującą wybranego silnika.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement bh
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="9">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logiczne
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nóżka
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Szyna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funkcja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPIO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nóżka
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Szyna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funkcja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPIO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prawy chwytak
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prawe ramię
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noga prawa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Biodro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noga lewa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
139
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lewe ramię
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PA25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lewy chwytak
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
141
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PB18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PWM6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
78
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PA26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ODER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:wyprowadzenia-pwm"

\end_inset

Zestawienie wyprowadzeń użytych do sterowania silników elektrycznych
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wszystkie wyprowadzenia mikrokontrolera operują na poziomach logicznych
 
\begin_inset Quotes pld
\end_inset

0
\begin_inset Quotes prd
\end_inset

 i 
\begin_inset Quotes pld
\end_inset

1
\begin_inset Quotes prd
\end_inset

, który odpowiadają napięcia 0.2
\begin_inset space ~
\end_inset

V oraz 3.2
\begin_inset space ~
\end_inset

V.
 Są one w parach (według wierszy tabeli 
\begin_inset CommandInset ref
LatexCommand vref
reference "tab:wyprowadzenia-pwm"

\end_inset

) podłączone do wejść logicznych siedmiu układów TC4424A umieszczonych na
 module sterowania zasilaniem opisanym w podrozdziale 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Moduł-sterowania-zasilaniem"

\end_inset

.
 Sterowanie wyjściami logicznymi powoduje sterowanie wyjściami zasilania
 silników elektrycznych, przy czym polaryzacja zależy od podawania na wejścia
 logiczne pary stanów 
\begin_inset Quotes pld
\end_inset

01
\begin_inset Quotes prd
\end_inset

 lub 
\begin_inset Quotes pld
\end_inset

10
\begin_inset Quotes prd
\end_inset

.
 Dodatkowo sterowanie PWM pozwala na regulację obrotów silnika.
 Dzięki funkcjonalności pozwalającej na zmianę polaryzacji PWM, proces ten
 może odbywać się w obu kierunkach.
\end_layout

\begin_layout Standard
Zmiana polaryzacji PWM oznacza, że przebieg prostokątny generowany z modulatora
 impulsów jest logicznie zanegowany.
 Z elektrycznego punktu widzenia 
\series bold
nie następuje
\series default
 zmiana polaryzacji z dodatniej na ujemną lub z ujemnej na dodatnią.
\end_layout

\begin_layout Chapter
Architektura systemu
\end_layout

\begin_layout Standard
Opis architektury systemu znajduje się tak odlegle od początku, ponieważ
 ma największe znaczenie dla oprogramowania stworzonego do realizacji tego
 projektu.
 Szczegóły architektury podsystemu mikrokontrolera oraz podsystemu zdalnej
 kontroli klarowały się w trakcie realizacji, jako uszczegółowienia ogólnej
 wizji projektu.
\end_layout

\begin_layout Section
Architektura ogólna
\end_layout

\begin_layout Section
Architektura podsystemu układu mikrokontrolera
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/system-arch-general.svg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schemat blokowy podsystemu układu mikrokontrolera
\end_layout

\end_inset


\end_layout

\end_inset

Jedną z części systemu sterowania robotem stanowi układ kontrolno-sterujący
 oparty o mikrokontroler AT32UC3A0512, w tym przypadku bazujący na bazie
 zestawu ewaluacyjnego EVK1100, do którego dołożone są dodatkowe elementy:
\end_layout

\begin_layout Itemize
Komunikacja bezprzewodowa w technologii Bluetooth
\end_layout

\begin_layout Itemize
Kamera cyfrowa 1/4.5
\begin_inset Quotes prd
\end_inset

 firmy Pixelplus
\end_layout

\begin_layout Itemize
Układ zasilania silników elektrycznych sterowany cyfrowo oparty o układy
 buforujące
\end_layout

\begin_layout Standard
Część tego podsystemu stanowi oprogramowanie odpowiadające za komunikację
 z podsystemem zdalnej kontroli działającym na komputerze PC oraz sterowanie
 realizacją poleceń i transmisją obrazu.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vector/system-arch-avr-soft.svg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Architektura oprogramowania układu mikrokontrolera
\end_layout

\end_inset


\end_layout

\end_inset

Oprogramowanie to działa na bazie systemu operacyjnego FreeRTOS
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Strona domowa systemu FreeRTOS: 
\begin_inset CommandInset href
LatexCommand href
name "http://www.freertos.org/"
target "http://www.freertos.org/"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Architektura podsystemu zdalnej kontroli
\end_layout

\begin_layout Standard
W realizacji tego projektu istotną rolę odgrywają pewne decyzje technologiczne
 dotyczące wyboru kanału komunikacji robota z komputerem PC.
 Technologia Bluetooth (opis: 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Bluetooth"

\end_inset

) jest dostępna we współczesnych komputerach przenośnych (ang.
 
\shape italic
\lang british
notebook computer
\shape default
\lang polish
), potocznie zwanych 
\begin_inset Quotes pld
\end_inset

laptopami
\begin_inset Quotes prd
\end_inset

.
 Oznacza to, że realizacja tego elementu systemu, który pozwala na wprowadzanie
 komend sterujących sprowadza się do napisania oprogramowania.
 Poniżej znajduje się uproszczony opis architektury tej aplikacji.
\end_layout

\begin_layout Standard
Szczegółowa dokumentacja projektowa tego fragmentu systemu znajduje się
 w załączniku 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Dokumentacja-programu-Robotiq"

\end_inset

 w języku angielskim i jest rezultatem automatycznej generacji dokumentacji
 przez system Doxygen 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rozważyć dodanie Doxygen'a do narzędzi.
\end_layout

\end_inset

.
\end_layout

\begin_layout Chapter
Realizacja oprogramowania
\end_layout

\begin_layout Section
Oprogramowanie mikrokontrolera (sprzętu)
\end_layout

\begin_layout Standard
Oprogramowanie mikrokontrolera napisane jest w języku C i zawiera elementy
 szkieletu programowego w wersji 1.3.0, w tym system operacyjny FreeRTOS w
 wersji 4.7.2.
\end_layout

\begin_layout Subsection
Przygotowanie szkieletu programowego i systemu FreeRTOS
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Opis ożenku FreeRTOS 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Konfiguracja środowiska do pracy z pamięcią SDRAM
\end_layout

\begin_layout Standard
Standardowo środowisko ramowe firmy Atmel w wersji 1.3.0 (patrz: 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Środowisko-ramowe"

\end_inset

) jest tak skonfigurowane, aby sterta
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Sterta (ang.
 
\shape italic
\lang british
heap
\shape default
\lang polish
) to obszar pamięci programu, gdzie przechowywane są zmienne dynamiczne
 oraz obszary danych alokowane na żądanie programisty.
\end_layout

\end_inset

 mieściła się w wewnętrznej pamięci mikrokontrolera AT32UC3A0512.
 Aplikacja w tym projekcie przewiduje większe potrzeby pamięciowe, niż dostępna
 pamięć 64 kB.
 Karta EVK1100 jest fabrycznie wyposażona w pamięć SDRAM
\begin_inset Foot
status open

\begin_layout Plain Layout
Model układu MT48LC16M16A2 opisany w 
\begin_inset CommandInset citation
LatexCommand cite
key "256msdram"

\end_inset

.
\end_layout

\end_inset

 o pojemności 32 MB.
 Opisane poniżej zmiany zostały wprowadzone na podstawie opisu dostarczonego
 przez firmę Atmel
\begin_inset CommandInset citation
LatexCommand cite
key "AVR32733"

\end_inset

.
\end_layout

\begin_layout Standard
Dostęp do pamięci zewnętrznej wymaga inicjalizacji kontrolera pamięci dynamiczne
j.
 Służy do tego funkcja 
\begin_inset listings
lstparams "language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

sdramc_init()
\end_layout

\end_inset

 dostępna w środowisku ramowym jako sterownik kontrolera pamięci.
 Aby jednak pamięć stała się dostępna odpowiednio wcześnie, wywołanie tej
 funkcji musi nastąpić w początkowej fazie uruchamiania kodu.
 Potrzebne są do tego następujące kroki:
\end_layout

\begin_layout Enumerate
Napisanie własnej funkcji 
\begin_inset listings
lstparams "language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

__init_startup()
\end_layout

\end_inset

,
\end_layout

\begin_layout Enumerate
Podstawienie prawidłowego pliku 
\family typewriter
crt0.x
\family default
,
\end_layout

\begin_layout Enumerate
Utworzenie nowego skryptu dla programu konsolidującego (ang.
 
\shape italic
\lang british
linker
\shape default
\lang polish
),
\end_layout

\begin_layout Enumerate
Ustawienie opcji programu konsolidującego
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
W AVR32 Studio we właściwościach projektu rozwijamy ustawienia 
\emph on
\lang british
C/C++ Build
\emph default
\lang polish
 i wybieramy 
\emph on
\lang british
Settings
\emph default
\lang polish
, w zakładce 
\emph on
\lang british
Tool Settings
\emph default
\lang polish
 wybieramy z grupy 
\emph on
\lang british
AVR32/GNU C Linker
\emph default
\lang polish
 obszar 
\emph on
\lang british
General
\emph default
\lang polish
 i zaznaczamy opcję 
\emph on
\lang british
Do not use standard start files (-nostartfiles)
\emph default
\lang polish
, następnie w obszarze 
\emph on
\lang british
Miscellaneous
\emph default
\lang polish
 wpisujemy w wierszy oznaczonym Linker flags podane parametry programu konsolidu
jącego.
\end_layout

\end_inset

 na 
\begin_inset listings
lstparams "breakautoindent=true,breaklines=true,language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

-Wl,--gc-sections -Wl,-e,_trampoline -Wl,--defsym,__heap_size__=0x00200000
 -Tlink_uc3a0512_extsdram.lds
\end_layout

\end_inset

, przy czym należy pamiętać, że plik 
\family typewriter
trampoline.x
\family default
 musi być kompilowany w projekcie, aby następował prawidłowy skok początkowy
 po starcie.
\end_layout

\begin_layout Standard
Nowe pliki znajdują się w katalogu 
\family typewriter
platform
\family default
.
 Istotny kod funkcji wspomnianej powyżej, powinien zawierać:
\begin_inset listings
lstparams "basicstyle={\ttfamily},breakatwhitespace=true,breakautoindent=true,breaklines=true,language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void __init_startup(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    /* ...
 some other initialization code ...
 */
\end_layout

\begin_layout Plain Layout

	/* Switch to external oscillator 0 */
\end_layout

\begin_layout Plain Layout

	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Initialize the SDRAM Controller and the external memory chip.
 */
\end_layout

\begin_layout Plain Layout

	sdramc_init(FOSC0);
\end_layout

\begin_layout Plain Layout

    /* ...
 some other initialization code ...
 */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

przy czym w pliku 
\family typewriter
port.c
\family default
 dla FreeRTOS w oryginalnym szkielecie programowym powyższa funkcja jest
 już zdefiniowana i wymagała zmiany.
 Obsługa pamięci SDRAM wymaga taktowania procesora z oscylatora zewnętrznego.
\end_layout

\begin_layout Standard
Plik konfiguracji programu konsolidującego 
\family typewriter
link_uc3a0512_extsdram.lds
\family default
 zawiera przeniesienie segmentu stosu 
\family typewriter
.heap
\family default
 do obszaru adresowanego przypisanego dla pamięci SDRAM.
 Dodatkowo tworzy dwa dodatkowe segmenty 
\family typewriter
.bss_sdram
\family default
 i 
\family typewriter
.data_sdram
\family default
, dla odpowiednio zmiennych niezainicjalizowanych i zmiennych zainicjalizowanych.
 Do zastosowania tych dwóch segmentów należy dodać dyrektywę 
\begin_inset listings
lstparams "language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

__attribute__((__section__(
\begin_inset Quotes pld
\end_inset

section-name
\begin_inset Quotes prd
\end_inset

)))
\end_layout

\end_inset

 przed deklarację zmiennej.
\end_layout

\begin_layout Subsection
Konfiguracja dla częstotliwości 66 MHz
\end_layout

\begin_layout Standard
Mikrokontroler AT32UC3A0512 (opisany w
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Mikrokontroler-AT32UC3A0512"

\end_inset

) może pracować z maksymalną częstotliwością 66 MHz, przy czym ta częstotliwość
 pracy osiągana jest z pętli sprzężenia fazowego PLL (ang.
 
\shape italic
\lang british
Phase Locked Loop
\shape default
\lang polish
) konfigurowalnej cyfrowo w module menadżera zasilania PM (ang.
 Power Manager).
 Aby otrzymać właściwą prędkość pracy należy rejestry 
\family typewriter
PLLMUL
\family default
, 
\family typewriter
PLLDIV
\family default
, 
\family typewriter
PLLOPT
\family default
 pętli o numerze 0 skonfigurować według następujących wzorów:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Dodać obrazki ze stron 57, 58 specyfikacji procka.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f_{vco}=\frac{(\mathtt{PLLMUL}+1)}{\mathtt{PLLDIV}}f_{osc},$
\end_inset

gdy 
\begin_inset Formula $\mathtt{PLLDIV}>0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $f_{vco}=2(\mathtt{PLLMUL}+1)f_{osc}$
\end_inset

, gdy 
\begin_inset Formula $\mathtt{PLLDIV}=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $f_{pll}=f_{vco}$
\end_inset

, gdy 
\begin_inset Formula $\mathtt{PLLOPT[1]}=0$
\end_inset

 lub 
\begin_inset Formula $f_{pll}=\frac{f_{vco}}{2}$
\end_inset

, gdy 
\begin_inset Formula $\mathtt{PLLOPT[1]}=1$
\end_inset

.
\end_layout

\begin_layout Standard
Następnie należy dokonać przełączenia głównego zegara na sygnał z pętli
 PLL0 poprzez ustawienie bitu 
\family typewriter
MCSEL
\family default
 rejestru 
\family typewriter
MCCTRL
\family default
 (ang.
 
\shape italic
\lang british
Main Clock Control Register
\shape default
\lang polish
).
\end_layout

\begin_layout Standard
Przy konfigurowaniu zegarów należy pamiętać, że ten mikrokontroler może
 pracować z maksymalną częstotliwością dla 66 MHz dla bloków CPU, HSB i
 PBB, jednakże blok PBA może pracować z maksymalną częstotliwością 33 MHz.
 Oznacza to, że należy włączyć preskaler dzielący częstotliwość PLL przez
 2.
 Osiąga się to przez ustawienie bitu 
\family typewriter
PBADIV
\family default
 na 1 i 
\family typewriter
PBASEL
\family default
 na 0 (dzielnik częstotliwości preskalera to 
\begin_inset Formula $2^{(\mathtt{PBASEL}+1)}$
\end_inset

).
 Podane ograniczenie wynika z faktu, że w bloku PBA znajdują się wolniejsze
 peryferia, na przykład UART, PWM, SPI.
\end_layout

\begin_layout Standard
Środowisko ramowe (
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Środowisko-ramowe"

\end_inset

) zawiera funkcję 
\family typewriter
pm_configure_clocks()
\family default
, która sprowadza konfigurację zegarów do wpisania oczekiwań w strukturę
 danych, a następnie dokonuje obliczeń dopasowujących opisane rejestry.
 W wyniku jej działania procesor rozpoczyna pracę na podanej częstotliwości
 i modyfikuje zawartość struktury według wyliczonych wartości.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void vq_init_clock(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int pm_status; 
\end_layout

\begin_layout Plain Layout

	/* Put clock configuration into structure */
\end_layout

\begin_layout Plain Layout

	pm_freq_param_t freq_param = {
\end_layout

\begin_layout Plain Layout

			.cpu_f = configCPU_CLOCK_HZ,
\end_layout

\begin_layout Plain Layout

			.pba_f = configPBA_CLOCK_HZ,
\end_layout

\begin_layout Plain Layout

			.osc0_f = FOSC0,
\end_layout

\begin_layout Plain Layout

			.osc0_startup = OSC0_STARTUP
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

	/* Configure CPU by PLL clocking */
\end_layout

\begin_layout Plain Layout

	pm_status = pm_configure_clocks(&freq_param);
\end_layout

\begin_layout Plain Layout

	/* ...
 */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Możliwość wykorzystywania pamięci SDRAM wymaga, aby inicjalizacja ostatecznej
 prędkości pracy odbyła się zanim zostanie wykorzystana sterta do alokacji
 pamięci przydzielanej dynamicznie.
 Aby tego dokonać wywołanie powyższej funkcji musi znaleźć się w funkcji
 
\begin_inset listings
lstparams "language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

__init_startup()
\end_layout

\end_inset

, zastępując wywołanie funkcji 
\begin_inset listings
lstparams "language=C,tabsize=4"
inline true
status open

\begin_layout Plain Layout

pm_switch_to_osc0()
\end_layout

\end_inset

.
 Dzięki temu minimalizujemy zmiany oryginalnego portu dostarczonego wraz
 ze środowiskiem ramowym.
\end_layout

\begin_layout Subsection
Mechanizmy zabezpieczeń alokacji pamięci
\end_layout

\begin_layout Standard
W systemie FreeTOS z planistą (ang.
 
\shape italic
\lang british
scheduler
\shape default
\lang polish
) wywłaszczającym (ang.
 
\shape italic
\lang british
preemptive
\shape default
\lang polish
) należy zadbać, aby alokacje pamięci nie zostały przerwane przez wywłaszczenie.
 Biblioteka newlib przewiduje dwie metody
\begin_inset CommandInset citation
LatexCommand cite
key "gatliff-newlib-2"

\end_inset

:
\end_layout

\begin_layout Enumerate
Implementacja funkcji 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

malloc()
\end_layout

\end_inset

 w oparciu o zastosowany w projekcie system operacyjny i jego wbudowane
 mechanizmy zarządzania dostępną pamięcią.
 W takiej sytuacji zamiast funkcji bibliotecznej włączona zostaje nasza
 implementacja.
\end_layout

\begin_layout Enumerate
Implementacja funkcji 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

__malloc_lock()
\end_layout

\end_inset

 i 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

__malloc_unlock()
\end_layout

\end_inset

 w celu zabezpieczenia wywołań do newralgicznych struktur danych o przydzielonej
 pamięci w przypadku kolidujących wywołań z różnych zadań (ang.
 
\emph on
\lang british
task
\emph default
\lang polish
).
 Metoda ta wymaga jednak bezpiecznego stosowania mechanizmów synchronizujących,
 aby uniknąć zakleszczenia związanego z podwójnym wywołaniem 
\begin_inset listings
lstparams "language=C"
inline true
status open

\begin_layout Plain Layout

__malloc_lock()
\end_layout

\end_inset

 przez kod biblioteczny.
\end_layout

\begin_layout Section
Oprogramowanie sterujące
\end_layout

\begin_layout Standard
Oprogramowanie sterujące o nazwie kodowej Robotiq zostało zrealizowane w
 języku Python.
 Interfejs graficzny oparty jest o bibliotekę GTK+.
 Aplikacja ta pozwala na wydawanie poleceń tekstowych, posiada fragment
 interfejsu upodobniony do oryginalnego kontrolera RoboActor.
 Widok okna aplikacji przedstawia rysunek 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Zrzut-ekranu-Robotiq"

\end_inset

 (aktualnie wymaga dopracowania).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
zdjęcia pilota + screen shot programu
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/robotiq_scrsht.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Zrzut-ekranu-Robotiq"

\end_inset

Zrzut ekranu aplikacji Robotiq
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zależności
\end_layout

\begin_layout Standard
Aby uruchomić aplikację sterującą należy posiadać zainstalowany interpreter
 języka Python w wersji 2.6.1.
 Dodatkowo następujące rozszerzenia muszą być zainstalowane:
\end_layout

\begin_layout Enumerate
PyGTK 2.12.1 -- dostępne pod adresem 
\begin_inset CommandInset href
LatexCommand href
target "http://ftp.gnome.org/pub/GNOME/binaries/win32/pygtk/"

\end_inset


\end_layout

\begin_layout Enumerate
PyGObject 2.14.2 -- dostępne pod adresem 
\begin_inset CommandInset href
LatexCommand href
target "http://ftp.gnome.org/pub/GNOME/binaries/win32/pygobject/"

\end_inset


\end_layout

\begin_layout Enumerate
PyCairo 1.4.12 -- dostępne pod adresem 
\begin_inset CommandInset href
LatexCommand href
target "http://ftp.gnome.org/pub/GNOME/binaries/win32/pycairo/"

\end_inset


\end_layout

\begin_layout Enumerate
PySerial 2.4 -- dostępne pod adresem 
\begin_inset CommandInset href
LatexCommand href
target "http://pyserial.wiki.sourceforge.net/pySerial"

\end_inset


\end_layout

\begin_layout Standard
W przypadku uruchamiania aplikacji w systemie operacyjnym Windows, należy
 zainstalować rozszerzenie:
\end_layout

\begin_layout Enumerate
PyWin32 build 312 -- dostępne pod adresem 
\begin_inset CommandInset href
LatexCommand href
target "http://sourceforge.net/projects/pywin32/"

\end_inset


\end_layout

\begin_layout Standard
Mniamuśnie.
\end_layout

\begin_layout Subsection
Organizacja aplikacji
\end_layout

\begin_layout Standard
Język Python pozwala organizować elementy aplikacji w postaci modułów, które
 mogą być pogrupowane w pakiety.
 Formalnie pakietem jest katalog, zawierający plik 
\family typewriter
__init__.py
\family default
.
 Dzięki temu plikowi mamy możliwość importowania modułów z takiego katalogu.
 W przypadku aplikacji Robotiq, zastosowany został podział logiczny elementów
 na następujące pakiety:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Pakiet
\begin_inset space ~
\end_inset

comm zawierający moduły odpowiedzialne za komunikację aplikacji z kontrolerem
 robota;
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Pakiet
\begin_inset space ~
\end_inset

misc zawierający moduły z różnorodnymi funkcjonalnościami nie klasyfikującymi
 się do innych pakietów;
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Pakiet
\begin_inset space ~
\end_inset

ui zawierający moduły odpowiedzialne za elementy interfejsu użytkownika.
\end_layout

\begin_layout Standard
Ponadto, istnieje kilka katalogów pomocniczych zawierających inne elementy
 stosowane przez aplikację w czasie jej działania:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter*
Podsumowanie
\end_layout

\begin_layout Standard
W trakcie realizacji opisywanego projektu wykonano modyfikacje konstrukcji
 robota, elektroniczny układ sterujący, oprogramowanie dla mikrokontrolera
 oraz oprogramowanie dla komputera PC.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Milion słów o niczym.
\end_layout

\end_inset


\end_layout

\begin_layout Part*
Załączniki
\end_layout

\begin_layout Chapter
\start_of_appendix
\begin_inset CommandInset label
LatexCommand label
name "cha:Dokumentacja-programu-Robotiq"

\end_inset

Dokumentacja programu Robotiq
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tu z Doxygen'a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "literatura"
options "plplain"

\end_inset


\end_layout

\end_body
\end_document
